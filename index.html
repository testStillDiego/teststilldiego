<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Contact Sheet - Interactive Review</title>
    <!-- Firebase SDK for real-time notes sync -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script>
        // Set viewport variables immediately before any CSS loads - critical for mobile Safari and Android
        (function() {
            function setViewportVariables() {
                const vh = window.innerHeight * 0.01;
                const vw = window.innerWidth * 0.01;
                document.documentElement.style.setProperty('--vh', vh + 'px');
                document.documentElement.style.setProperty('--vw', vw + 'px');
                document.documentElement.style.setProperty('--viewport-height', window.innerHeight + 'px');
                document.documentElement.style.setProperty('--viewport-width', window.innerWidth + 'px');

                // Detect if we're in landscape mode on a mobile device
                const isLandscape = window.innerWidth > window.innerHeight;
                const isMobileDevice = /iPhone|iPad|iPod|Android|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                // Mobile landscape: must be a mobile device AND in landscape orientation
                const isMobileLandscape = isLandscape && isMobileDevice && window.innerHeight < 500;
                document.documentElement.style.setProperty('--is-mobile-landscape', isMobileLandscape ? '1' : '0');
                document.documentElement.classList.toggle('mobile-landscape', isMobileLandscape);
                document.documentElement.classList.toggle('mobile-portrait', !isLandscape && window.innerWidth < 768);
            }
            setViewportVariables();
            window.addEventListener('resize', setViewportVariables);
            window.addEventListener('orientationchange', function() {
                // Delay after orientation change for Safari/Android to settle
                setTimeout(setViewportVariables, 50);
                setTimeout(setViewportVariables, 150);
                setTimeout(setViewportVariables, 300);
                setTimeout(setViewportVariables, 500);
            });
        })();
    </script>
    <style>
        /* ============================================================
           FRAMEDECK STUDIO INTERACTIVE CONTACT SHEET
           Dark Theme Matching FDS Aesthetic
           ============================================================ */

        /* System font stack - native look on each platform
           Mac: San Francisco, Windows: Segoe UI, Linux: Roboto */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Prevent white flash on load */
        html {
            background: #000000;
        }

        :root {
            /* FDS Color Palette */
            --fds-bg-dark: #1a1a1a;
            --fds-bg-medium: #2a2a2a;
            --fds-bg-soft: #3a3a3a;
            --fds-orange: #ff6e31;
            --fds-orange-hover: #ff5511;
            --fds-text: #e0e0e0;
            --fds-text-dim: #888888;
            --fds-border: #444444;
            /* Dynamic viewport height - set by JS, with multiple fallbacks */
            --vh: 1vh;
            --vw: 1vw;
            --viewport-height: 100vh;
            --viewport-width: 100vw;
            --is-mobile-landscape: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: #000000; /* Pure black background */
            color: var(--fds-text);
            line-height: 1.6;
            overflow-x: hidden;
            overflow-y: auto; /* Allow vertical scroll but prevent overscroll showing content below */
            position: relative;
            min-height: 100vh;
            /* Prevent overscroll bounce revealing white edges on iOS/Android */
            overscroll-behavior-x: none;
            overscroll-behavior-y: auto;
            /* Smooth scrolling on iOS */
            -webkit-overflow-scrolling: touch;
        }

        /* Lock body when modal is open to prevent background scrolling */
        body.modal-open {
            overflow: hidden;
        }

        /* iOS Safari fix: Hide grid behind modal to prevent GPU compositing ghost image */
        body.modal-open .contact-sheet-grid {
            display: none !important;
        }

        /* On Android, use position fixed to prevent background scroll issues */
        /* On iOS, avoid position:fixed as it breaks the natural swipe-to-hide-chrome behavior */
        html.is-android body.modal-open {
            position: fixed;
            width: 100%;
            height: 100%;
        }

        /* ============================================================
           HEADER
           ============================================================ */

        .header {
            background: linear-gradient(180deg,
                #323232 0%,      /* Slightly lighter at top */
                #2a2a2a 40%,     /* Blend to medium */
                #252525 100%);   /* Slightly darker at bottom */
            padding: 32px 40px 28px;
            position: sticky;
            top: 0;
            z-index: 100;
            /* Allow dropdown to overflow, but prevent horizontal scroll */
            overflow: visible;
            width: 100%;
            box-sizing: border-box;
        }

        /* Mobile header adjustments */
        @media (max-width: 768px) {
            .header {
                padding: 20px 16px 16px;
            }

            .header::after {
                left: 16px;
                right: 16px;
            }
        }

        /* Subtle divider line below header with shimmer animation */
        .header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 40px;
            right: 40px;
            height: 1px;
            background: linear-gradient(90deg,
                transparent 0%,
                var(--fds-border) 10%,
                var(--fds-border) 90%,
                transparent 100%);
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: -100%;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg,
                transparent 0%,
                var(--fds-orange) 50%,
                transparent 100%);
            animation: shimmer 3s ease-in-out 0.5s 1 forwards;
            opacity: 0;
        }

        @keyframes shimmer {
            0% {
                left: -100%;
                opacity: 0;
            }
            10% {
                opacity: 0.6;
            }
            90% {
                opacity: 0.6;
            }
            100% {
                left: 100%;
                opacity: 0;
            }
        }

        .header-content {
            max-width: 1800px;
            margin: 0 auto;
            position: relative;
        }

        .project-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            gap: 6px;
        }

        .project-title {
            font-size: 36px;
            font-weight: 700;
            color: #ffffff;
            letter-spacing: -0.5px;
            line-height: 1.1;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Orange accent line under title */
        .project-title::after {
            content: '';
            display: block;
            width: 120px;
            height: 2px;
            margin: 12px auto 0;
            background: linear-gradient(90deg,
                transparent 0%,
                var(--fds-orange) 20%,
                var(--fds-orange) 80%,
                transparent 100%);
            border-radius: 1px;
        }

        .project-subtitle {
            font-size: 15px;
            color: var(--fds-text-dim);
            font-weight: 400;
            font-style: italic;
        }

        .project-subtitle::before {
            content: 'Prepared for ';
            color: var(--fds-text-dim);
            opacity: 0.7;
        }

        /* Sheet notes - colorist context block between header and grid */
        .sheet-notes {
            background: linear-gradient(to bottom, #1d1d1d, #191919);
            border-top: 1px solid rgba(255, 255, 255, 0.06);
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
            margin-top: 12px;
            margin-bottom: 18px;
            padding: 22px 40px;
            text-align: left;
            display: flex;
            justify-content: center;
        }

        .sheet-notes-inner {
            max-width: 600px;
        }

        .sheet-notes-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            color: var(--fds-text-dim);
            opacity: 0.6;
            margin-bottom: 10px;
        }

        .sheet-notes-text {
            font-size: 14px;
            line-height: 1.6;
            color: var(--fds-text-dim);
            font-style: italic;
            padding: 4px 0 4px 16px;
            border-left: 3px solid var(--fds-orange);
            white-space: pre-wrap;
        }

        @media (max-width: 768px) {
            .sheet-notes {
                padding: 18px 16px;
            }
        }

        /* Controls positioned absolute top-right */
        .header-controls {
            position: absolute;
            top: 0;
            right: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 18px;
        }

        .header-controls-row {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        /* Filter controls positioned absolute top-left */
        .header-left {
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Download Photos button */
        .download-all-btn {
            background: var(--fds-bg-soft);
            border: 1px solid var(--fds-border);
            color: var(--fds-text);
            padding: 6px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            text-decoration: none;
        }

        .download-all-btn:hover {
            border-color: var(--fds-orange);
            color: var(--fds-orange);
        }

        .frame-counter {
            font-size: 15px;
            color: var(--fds-text-dim);
            font-weight: 500;
        }

        .grid-size-selector {
            display: flex;
            gap: 4px;
        }

        .grid-btn {
            background: var(--fds-bg-soft);
            border: 1px solid var(--fds-border);
            color: var(--fds-text);
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .grid-btn:hover {
            border-color: var(--fds-orange);
            color: var(--fds-orange);
        }

        .grid-btn.active {
            background: var(--fds-orange);
            border-color: var(--fds-orange);
            color: white;
        }

        /* Thumbnail Size Selector */
        .thumb-size-selector {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .thumb-size-selector::before {
            content: 'Size:';
            font-size: 11px;
            color: var(--fds-text-dim);
            margin-right: 2px;
        }

        .thumb-btn {
            background: var(--fds-bg-soft);
            border: 1px solid var(--fds-border);
            color: var(--fds-text);
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .thumb-btn:hover {
            border-color: var(--fds-orange);
            color: var(--fds-orange);
        }

        .thumb-btn.active {
            background: var(--fds-orange);
            border-color: var(--fds-orange);
            color: white;
        }

        /* Responsive: scale controls smaller on narrow screens to stay upper-right */
        @media (max-width: 1100px) {
            .header-controls {
                gap: 10px;
            }
            .frame-counter {
                display: none;
            }
            .grid-btn {
                padding: 4px 8px;
                font-size: 10px;
            }
            .thumb-size-selector::before {
                font-size: 10px;
            }
            .thumb-btn {
                padding: 4px 7px;
                font-size: 10px;
            }
        }

        @media (max-width: 900px) {
            .header {
                padding: 24px 20px 20px;
            }
            .project-title {
                font-size: 28px;
            }
            .project-subtitle {
                font-size: 13px;
            }
            .header-controls {
                gap: 8px;
            }
            .grid-btn {
                padding: 3px 6px;
                font-size: 9px;
            }
            .thumb-size-selector::before {
                display: none;
            }
            .thumb-btn {
                padding: 3px 6px;
                font-size: 9px;
            }
        }

        @media (max-width: 600px) {
            .header {
                padding: 16px 12px 14px;
            }
            .project-title {
                font-size: 22px;
            }
            .project-subtitle {
                font-size: 12px;
            }
            /* Hide grid and size controls on mobile - screen too small */
            .header-controls {
                display: none;
            }
        }

        /* Hide header controls on ALL mobile devices (iOS/Android) regardless of orientation */
        html.is-ios .header-controls,
        html.is-android .header-controls,
        html.is-ios .header-left,
        html.is-android .header-left {
            display: none !important;
        }

        /* Also hide on mobile-landscape class */
        html.mobile-landscape .header-controls,
        html.mobile-landscape .header-left {
            display: none !important;
        }

        /* ============================================================
           MOBILE HAMBURGER MENU
           ============================================================ */

        .mobile-menu-btn {
            display: none;
            position: absolute;
            top: 0;
            right: 0;
            background: transparent;
            border: none;
            color: var(--fds-text);
            font-size: 24px;
            padding: 8px 12px;
            cursor: pointer;
            z-index: 101;
            line-height: 1;
        }

        .mobile-menu-btn:hover {
            color: var(--fds-orange);
        }

        /* Show hamburger on mobile, reposition dropdown to right side */
        html.is-ios .mobile-menu-btn,
        html.is-android .mobile-menu-btn {
            display: block !important;
        }

        html.is-ios .filter-dropdown-menu,
        html.is-android .filter-dropdown-menu {
            left: auto;
            right: 12px;
            top: 60px;
            min-width: 220px;
        }

        html.is-ios .filter-dropdown-menu .filter-dropdown-item,
        html.is-android .filter-dropdown-menu .filter-dropdown-item {
            padding: 12px;
            font-size: 14px;
        }

        @media (max-width: 600px) {
            .mobile-menu-btn {
                display: block;
            }
            .filter-dropdown-menu {
                left: auto;
                right: 12px;
                top: 60px;
                min-width: 220px;
            }
            .filter-dropdown-menu .filter-dropdown-item {
                padding: 12px;
                font-size: 14px;
            }
        }

        /* Download section - shown above footer for all devices */
        .mobile-download-container {
            display: block;
            padding: 40px 16px;
            text-align: center;
            background: transparent;
        }

        .mobile-download-container .download-all-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 14px 32px;
            font-size: 15px;
            background: var(--fds-orange);
            border: none;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            text-decoration: none;
            transition: all 0.2s;
        }

        .mobile-download-container .download-all-btn:hover {
            background: var(--fds-orange-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 110, 49, 0.4);
        }

        /* ============================================================
           GRID LAYOUT
           ============================================================ */

        .grid-container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 40px;
            /* Prevent horizontal overflow on mobile */
            overflow-x: hidden;
        }

        /* Mobile-specific grid container adjustments */
        @media (max-width: 768px) {
            .grid-container {
                padding: 16px;
                /* Lock width to prevent any horizontal drift */
                width: 100%;
                max-width: 100vw;
                box-sizing: border-box;
            }
        }

        /* Thumbnail size variations - adjusts max-width of container */
        .grid-container.thumb-small {
            max-width: 1100px;
        }

        .grid-container.thumb-medium {
            max-width: 1400px;
        }

        .grid-container.thumb-large {
            max-width: 1800px; /* Default */
        }

        .grid-container.thumb-max {
            max-width: 2200px;
        }

        .grid-container.thumb-huge {
            max-width: 2600px;
        }

        .contact-sheet-grid {
            display: grid;
            gap: 24px;
            margin-bottom: 40px;
        }

        /* Grid size variations */
        .contact-sheet-grid.grid-2x2 {
            grid-template-columns: repeat(2, 1fr);
        }

        .contact-sheet-grid.grid-3x3 {
            grid-template-columns: repeat(3, 1fr);
        }

        .contact-sheet-grid.grid-4x4 {
            grid-template-columns: repeat(4, 1fr);
        }

        .contact-sheet-grid.grid-5x5 {
            grid-template-columns: repeat(5, 1fr);
        }

        /* Responsive breakpoints */
        @media (max-width: 1600px) {
            .contact-sheet-grid.grid-5x5 {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (max-width: 1400px) {
            .contact-sheet-grid.grid-4x4,
            .contact-sheet-grid.grid-5x5 {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 1024px) {
            .contact-sheet-grid.grid-3x3,
            .contact-sheet-grid.grid-4x4,
            .contact-sheet-grid.grid-5x5 {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .contact-sheet-grid {
                grid-template-columns: 1fr !important;
            }
        }

        /* ============================================================
           THUMBNAIL CARD
           ============================================================ */

        .thumbnail-card {
            background: var(--fds-bg-medium);
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.25s ease, box-shadow 0.25s ease, border-color 0.2s ease;
            border: 2px solid transparent;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        /* Reviewed state - green border (client has viewed this frame) */
        .thumbnail-card.reviewed {
            border-color: #4CAF50; /* Material green */
        }

        /* Favorited state - orange border (overrides reviewed) */
        .thumbnail-card.favorited {
            border-color: var(--fds-orange);
        }

        .thumbnail-card:hover {
            transform: translateY(-6px) scale(1.01);
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.5);
            border-color: var(--fds-orange);
        }

        .thumbnail-card.selected {
            border-color: var(--fds-orange);
        }

        .thumbnail-image-container {
            position: relative;
            width: 100%;
            padding-top: 56.25%; /* 16:9 aspect ratio */
            background: #1a1a1a; /* Darker black for contrast with info bar */
            overflow: hidden;
        }

        .thumbnail-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0;
            animation: fadeIn 0.4s ease forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Metadata overlay pills on thumbnails */
        .thumbnail-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .metadata-pill {
            position: absolute;
            background: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 6px 14px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
            backdrop-filter: blur(4px);
        }

        /* Pill positioning - horizontal only, vertical set by JS for stacking */
        .pill-top-left {
            left: 16px;
            /* top set dynamically by JS */
        }

        .pill-top-right {
            right: 16px;
            /* top set dynamically by JS */
        }

        .pill-bottom-left {
            left: 16px;
            /* bottom set dynamically by JS */
        }

        .pill-bottom-right {
            right: 16px;
            /* bottom set dynamically by JS */
        }

        /* Favorite star badge */
        .favorite-badge {
            position: absolute;
            top: 12px;
            right: 12px;
            background: transparent;
            color: #ffcc00; /* Yellow star */
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            text-shadow: 0 2px 6px rgba(0, 0, 0, 0.9), 0 1px 3px rgba(0, 0, 0, 0.7); /* Double shadow for depth */
        }

        /* ============================================================
           CLIENT FEEDBACK BADGE
           ============================================================ */

        .feedback-badge {
            position: absolute;
            bottom: 12px;
            left: 12px;
            font-size: 20px;
            line-height: 1;
            display: none;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.9), 0 0 12px rgba(0, 0, 0, 0.6);
            cursor: default;
            z-index: 5;
        }

        .feedback-badge.visible {
            display: block;
        }

        /* ============================================================
           FILTER/SORT CONTROLS
           ============================================================ */

        .filter-sort-container {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        /* Custom dropdown styling */
        .filter-dropdown {
            position: relative;
            min-width: 165px;
        }

        .filter-dropdown-btn {
            background: var(--fds-bg-soft);
            border: 1px solid var(--fds-border);
            color: var(--fds-text);
            padding: 6px 28px 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
            width: 100%;
            text-align: left;
            position: relative;
        }

        .filter-dropdown-btn::after {
            content: '▼';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 8px;
            opacity: 0.7;
            transition: transform 0.2s;
        }

        .filter-dropdown-btn:hover {
            border-color: var(--fds-orange);
            color: var(--fds-orange);
        }

        .filter-dropdown.open .filter-dropdown-btn::after {
            transform: translateY(-50%) rotate(180deg);
        }

        .filter-dropdown-menu {
            position: absolute;
            top: 45px;
            left: 0;
            min-width: 200px;
            background: var(--fds-bg-medium);
            border: 1px solid var(--fds-border);
            border-radius: 4px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 1000; /* High z-index to overlay grid */
        }

        .filter-dropdown-menu.open {
            display: block;
        }

        .filter-dropdown-section {
            padding: 6px 0;
            border-bottom: 1px solid var(--fds-border);
        }

        .filter-dropdown-section:last-child {
            border-bottom: none;
        }

        .filter-dropdown-section-title {
            padding: 4px 12px;
            font-size: 10px;
            font-weight: 600;
            color: var(--fds-text-dim);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .filter-dropdown-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 12px;
            color: var(--fds-text);
            transition: background 0.15s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .filter-dropdown-item:hover {
            background: var(--fds-bg-soft);
        }

        .filter-dropdown-item.active {
            background: rgba(255, 110, 49, 0.15);
            color: var(--fds-orange);
        }

        .filter-dropdown-item .item-icon {
            width: 16px;
            text-align: center;
            font-size: 12px;
        }

        .filter-dropdown-item .item-count {
            margin-left: auto;
            font-size: 11px;
            color: var(--fds-text-dim);
            background: var(--fds-bg-dark);
            padding: 2px 6px;
            border-radius: 8px;
        }

        /* Active filter indicator */
        .filter-dropdown-btn.has-filter {
            background: rgba(255, 110, 49, 0.15);
            border-color: var(--fds-orange);
            color: var(--fds-orange);
        }

        /* Reset button */
        .filter-reset-btn {
            background: transparent;
            border: none;
            color: var(--fds-text-dim);
            cursor: pointer;
            font-size: 11px;
            padding: 6px 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .filter-reset-btn:hover {
            color: var(--fds-orange);
            background: var(--fds-bg-soft);
        }

        .filter-reset-btn.hidden {
            display: none;
        }

        /* Hide filter controls on mobile (same as other header controls) */
        html.is-ios .filter-sort-container,
        html.is-android .filter-sort-container,
        html.mobile-landscape .filter-sort-container {
            display: none !important;
        }

        @media (max-width: 600px) {
            .filter-sort-container {
                display: none;
            }
        }

        /* Thumbnail info bar - separate dark bar below image */
        .thumbnail-info {
            background: linear-gradient(180deg,
                #3a3a3a 0%,      /* Slightly lighter at top */
                #333333 40%,     /* Blend to standard */
                #2e2e2e 100%);   /* Slightly darker at bottom */
            padding: 12px 16px;
        }

        .thumbnail-tc {
            color: var(--fds-orange);
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 4px;
            letter-spacing: 0.02em;
        }

        .thumbnail-shot {
            color: #999999;
            font-size: 12px;
            font-weight: 500;
        }

        /* ============================================================
           MODAL VIEWER
           ============================================================ */

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95); /* Pure black backdrop */
            z-index: 1000;
            display: none;
            align-items: flex-start; /* Changed from center to flex-start for mobile */
            justify-content: center;
            padding: 20px;
            /* Force hardware acceleration for better Android performance */
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
            /* Prevent overscroll bounce on iOS/Android */
            overscroll-behavior: contain;
            -webkit-overflow-scrolling: touch;
            /* Use CSS variable for height with dvh fallback */
            height: 100dvh;
            height: var(--viewport-height, 100vh);
            /* Allow scrolling on mobile portrait when content is tall */
            overflow-y: auto;
        }

        .modal-overlay.active {
            display: flex;
        }

        /* Loading state - hide content until image is ready to prevent flash */
        .modal-overlay.loading .modal-content {
            opacity: 0;
        }

        .modal-overlay:not(.loading) .modal-content {
            opacity: 1;
            transition: opacity 0.15s ease-in;
        }

        /* Desktop: center the modal content */
        @media (min-width: 769px), (orientation: landscape) and (min-height: 501px) {
            .modal-overlay {
                align-items: center;
                overflow-y: hidden;
            }
        }

        /* Portrait-specific: scrollable modal that starts from top */
        @media (orientation: portrait) {
            .modal-overlay {
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                /* Reduced padding - let content breathe */
                padding-top: max(12px, env(safe-area-inset-top));
                padding-bottom: max(12px, env(safe-area-inset-bottom));
                padding-left: max(8px, env(safe-area-inset-left));
                padding-right: max(8px, env(safe-area-inset-right));
                /* Allow vertical scroll for tall content */
                overflow-y: auto;
                align-items: flex-start;
            }

            .modal-content {
                /* Don't constrain max-height - let it be naturally sized */
                max-width: calc(100vw - 16px);
                max-height: none;
                margin-top: 0;
                margin-bottom: 20px;
            }

            /* Make the right panel scrollable so notes are always accessible */
            .modal-right {
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                overscroll-behavior: contain;
                flex-shrink: 0;
                /* Bottom padding for Safari chrome */
                padding-bottom: 120px !important;
            }

            /* Minimal bottom margin on textareas */
            .modal-right textarea {
                margin-bottom: 12px;
            }
        }

        .modal-content {
            width: auto;
            height: auto;
            min-width: 300px; /* Prevent collapse on Android */
            min-height: 200px; /* Prevent collapse on Android */
            max-width: 95vw;
            max-height: 95vh;
            background: transparent;
            border-radius: 12px;
            display: flex;
            align-items: stretch; /* Both panels same height */
            gap: 8px;
            position: relative;
        }

        /* Close button */
        .modal-close {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 32px;
            height: 32px;
            background: rgba(42, 42, 42, 0.9);
            border: 1px solid var(--fds-border);
            border-radius: 6px;
            color: var(--fds-text);
            font-size: 20px;
            cursor: pointer;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            backdrop-filter: blur(4px);
        }

        .modal-close:hover {
            background: var(--fds-orange);
            border-color: var(--fds-orange);
            color: white;
        }

        /* Fullscreen button - for Android/desktop */
        .modal-fullscreen {
            position: absolute;
            top: 8px;
            left: 8px; /* Upper LEFT to avoid conflict with close button and metadata pills on right */
            width: 32px;
            height: 32px;
            background: rgba(42, 42, 42, 0.9);
            border: 1px solid var(--fds-border);
            border-radius: 6px;
            color: var(--fds-text);
            font-size: 18px;
            cursor: pointer;
            z-index: 1000;
            display: none; /* Hidden by default, shown via JS on supported devices */
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            backdrop-filter: blur(4px);
        }

        .modal-fullscreen:hover {
            background: var(--fds-orange);
            border-color: var(--fds-orange);
            color: white;
        }

        .modal-fullscreen.active {
            background: var(--fds-orange);
            border-color: var(--fds-orange);
        }

        /* Show fullscreen button in landscape on mobile (where it's useful) */
        @media (orientation: landscape) and (max-height: 600px) {
            .modal-fullscreen {
                display: flex;
            }
        }

        /* Also show on Android detection via JS class */
        html.is-android .modal-fullscreen {
            display: flex;
        }

        /* Hide on iOS (they have native fullscreen via swipe) */
        html.is-ios .modal-fullscreen {
            display: none;
        }

        /* In landscape mobile mode, position buttons safely */
        @media (orientation: landscape) and (max-height: 600px) {
            .modal-close {
                top: 8px;
                right: 8px;
            }
            .modal-fullscreen {
                top: 8px;
                left: 8px;
            }
        }

        /* Fullscreen mode styles */
        .modal-overlay.fullscreen-mode {
            background: #000000;
        }

        .modal-overlay.fullscreen-mode .modal-content {
            max-width: 100vw;
            max-height: 100vh;
            border-radius: 0;
        }

        .modal-overlay.fullscreen-mode .modal-left {
            border-radius: 0;
        }

        /* Left panel - Image viewer */
        .modal-left {
            display: flex;
            flex-direction: column;
            position: relative;
            background: #1a1a1a;
            padding: 20px;
            padding-bottom: 0;
            border-radius: 12px;
        }

        /* Wrapper for image to center it */
        .modal-image-wrapper {
            display: flex;
            align-items: center;
            justify-content: center;
            padding-bottom: 16px;
        }

        /* Image container */
        .modal-image-container {
            position: relative;
            display: inline-block;
            background: var(--fds-bg-dark);
            border: 0.5px solid var(--fds-border);
            border-radius: 8px;
            overflow: hidden;
        }

        .modal-image {
            display: block;
            max-width: calc(95vw - 500px); /* Viewport minus right panel + gaps */
            max-height: calc(95vh - 120px); /* Viewport minus info bar + padding */
            width: auto;
            height: auto;
        }

        /* Metadata overlay on modal image */
        .modal-image-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        /* Navigation arrows */
        .nav-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 56px;
            height: 56px;
            /* Default: More opaque/darker (like right button) */
            background: rgba(0, 0, 0, 0.7); /* 70% opaque - darker default */
            border: 2px solid rgba(255, 107, 53, 0.5); /* Subtle orange */
            border-radius: 50%;
            color: rgba(255, 255, 255, 0.85); /* Semi-bright arrow */
            font-size: 20px;
            font-weight: normal;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        .nav-arrow:hover:not(:disabled) {
            /* Hover: MORE transparent/lighter (like left button) */
            background: rgba(0, 0, 0, 0.45); /* 45% opaque - lighter on hover */
            border-color: rgba(255, 107, 53, 0.9); /* Bright orange glow */
            color: rgba(255, 255, 255, 0.95); /* Brighter arrow */
            transform: translateY(-50%) scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5),
                        0 0 20px rgba(255, 107, 53, 0.25); /* Orange glow */
        }

        .nav-arrow:active:not(:disabled) {
            /* Click: Back to more opaque */
            background: rgba(0, 0, 0, 0.8); /* 80% opaque on click */
            border-color: rgba(255, 107, 53, 1); /* Full orange */
            color: rgba(255, 255, 255, 1); /* Full white */
            transform: translateY(-50%) scale(0.98);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);
        }

        .nav-arrow:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            border-color: rgba(255, 107, 53, 0.2);
            background: rgba(0, 0, 0, 0.7);
            box-shadow: none;
        }

        .nav-arrow.prev {
            left: 20px;
        }

        .nav-arrow.next {
            right: 20px;
        }

        /* ====================================================================
           TOOLTIPS - FDS Style
           ==================================================================== */

        /* Tooltip styles - only applied to specific elements with .tooltip-enabled class */
        /* This prevents breaking existing positioning */

        .tooltip-enabled {
            position: relative;
            cursor: help;
        }

        .tooltip-enabled::before {
            content: attr(data-tooltip);
            position: absolute;
            bottom: calc(100% + 12px);
            left: 50%;
            transform: translateX(-50%) scale(0.95);
            padding: 10px 14px;
            background: rgba(42, 42, 42, 0.98);
            color: rgba(255, 255, 255, 0.95);
            font-size: 13px;
            line-height: 1.4;
            font-weight: 400;
            white-space: normal;
            max-width: 320px;
            border-radius: 8px;
            border: 1px solid rgba(255, 107, 53, 0.3);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            z-index: 10001; /* Above modal content */
            text-align: center;
        }

        .tooltip-enabled::after {
            content: '';
            position: absolute;
            bottom: calc(100% + 4px);
            left: 50%;
            transform: translateX(-50%) scale(0.95);
            border: 6px solid transparent;
            border-top-color: rgba(42, 42, 42, 0.98);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            z-index: 10001;
        }

        /* Favorite button: Don't override its ::after (it needs it for the star icon) */
        .modal-favorite-btn.tooltip-enabled::after {
            content: '☆'; /* Restore star - override tooltip */
            position: static;
            transform: none;
            border: none;
            opacity: 1;
            pointer-events: auto;
            transition: none;
            z-index: auto;
        }

        .modal-favorite-btn.tooltip-enabled.active::after {
            content: '★'; /* Filled star when favorited */
        }

        .tooltip-enabled:hover::before,
        .tooltip-enabled:hover::after {
            opacity: 1;
            transform: translateX(-50%) scale(1);
        }

        /* Favorite button hover: Keep ::after visible (star), only show ::before (tooltip) */
        .modal-favorite-btn.tooltip-enabled:hover::after {
            opacity: 1;
            transform: none;
        }

        /* Dropdown option tooltips (for starred items) - show BELOW since dropdown is at top */
        .fds-dropdown-option.tooltip-enabled::before {
            bottom: auto;
            top: calc(100% + 8px);
            white-space: nowrap;
        }

        .fds-dropdown-option.tooltip-enabled::after {
            bottom: auto;
            top: calc(100% + 0px);
            border-top-color: transparent;
            border-bottom-color: rgba(42, 42, 42, 0.98);
        }

        /* Ungraded label tooltip - show BELOW to prevent clipping at bottom of modal */
        label[for="viewUngraded"].tooltip-enabled::before {
            bottom: auto;
            top: calc(100% + 12px); /* Show below the label */
            left: 0; /* Align to left edge of label */
            transform: translateX(0) scale(0.95);
            max-width: 280px;
        }

        label[for="viewUngraded"].tooltip-enabled::after {
            bottom: auto;
            top: calc(100% + 4px); /* Show below the label */
            left: 20px; /* Position arrow near left side */
            transform: translateX(0) scale(0.95);
            border-top-color: transparent;
            border-bottom-color: rgba(42, 42, 42, 0.98); /* Arrow points up */
        }

        label[for="viewUngraded"].tooltip-enabled:hover::before,
        label[for="viewUngraded"].tooltip-enabled:hover::after {
            opacity: 1;
            transform: translateX(0) scale(1);
        }

        /* Frame info bar (below image) */
        .modal-frame-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: transparent; /* Transparent like FDS */
            border-top: none; /* No border separator */
            border-radius: 0 0 11px 11px; /* Rounded bottom-left AND bottom-right */
            gap: 16px;
        }

        .modal-frame-meta {
            display: flex;
            flex-direction: row; /* Same line instead of stacked */
            gap: 12px; /* Space between TC and Shot */
            align-items: center;
        }

        .modal-timecode {
            font-size: 14px;
            color: var(--fds-text); /* Same color as shot, not orange */
            font-weight: 600;
        }

        .modal-shot {
            font-size: 14px; /* Same size as TC */
            color: var(--fds-text); /* Match TC color */
        }

        .modal-shot::before {
            content: '| '; /* Separator */
            color: var(--fds-border);
            margin-right: 4px;
        }

        .modal-frame-counter {
            position: absolute; /* Overlay on image */
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%); /* Center horizontally */
            font-size: 14px;
            color: white;
            font-weight: 500;
            background: rgba(0, 0, 0, 0.6); /* Semi-transparent background */
            padding: 4px 12px;
            border-radius: 4px;
            backdrop-filter: blur(4px);
            z-index: 5;
        }

        /* Favorite button in modal */
        .modal-favorite-btn {
            background: transparent;
            border: none;
            color: var(--fds-text-dim);
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 28px; /* Larger star */
            transition: all 0.2s;
            min-width: 52px;
            line-height: 1;
        }

        .modal-favorite-btn:hover {
            color: #ffcc00;
        }

        .modal-favorite-btn.active {
            color: #ffcc00; /* Yellow star like FDS */
        }

        /* Outline vs filled star using pseudo-element */
        .modal-favorite-btn::after {
            content: '☆'; /* Outline star when not favorited */
        }

        .modal-favorite-btn.active::after {
            content: '★'; /* Filled star when favorited */
        }

        /* Right panel - Controls */
        .modal-right {
            width: 450px;
            min-width: 450px;
            flex-shrink: 0;
            background: #1a1a1a;
            border-left: none;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 12px 16px;
            padding-top: 0;
            border-radius: 12px;
        }

        .modal-section {
            padding: 20px 0;
            border-bottom: 1px solid var(--fds-border);
        }

        .modal-section:first-child {
            padding-top: 12px; /* Reduced - X button is smaller now */
            flex-shrink: 0; /* Don't shrink */
            overflow: visible; /* Allow dropdown to expand */
        }

        .modal-section:last-child {
            border-bottom: none;
            flex: 1; /* Take remaining space */
            display: flex;
            flex-direction: column;
            min-height: 0; /* Important for flex */
        }

        /* Photo Gallery Mode (no ungraded frames) - hide look options, expand notes */
        .no-ungraded .modal-section:first-child,
        .no-ungraded #lutPreviewSection {
            display: none !important;
        }

        .no-ungraded .modal-section:last-child {
            padding-top: 12px;
        }

        /* No Firebase Mode - hide client feedback section (colorist notes still visible) */
        .no-firebase #clientFeedbackContainer {
            display: none !important;
        }

        .modal-section-title {
            font-size: 15px; /* Match FDS title size */
            font-weight: 600;
            color: var(--fds-orange); /* Orange titles like FDS */
            margin-bottom: 16px;
            padding-right: 40px; /* Space for close button on first section */
        }

        .modal-section:not(:first-child) .modal-section-title {
            padding-right: 0; /* No extra padding on other sections */
        }

        /* Radio button group */
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .radio-option, .current-grade-row {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .radio-option:hover, .current-grade-row:hover {
            background: var(--fds-bg-medium);
        }

        /* Native radio button styling */
        .radio-option input[type="radio"],
        .current-grade-row input[type="radio"] {
            width: 16px;
            height: 16px;
            min-width: 16px;
            cursor: pointer;
            accent-color: var(--fds-orange);
        }

        /* Label styling - gray when unselected */
        .radio-option label,
        .current-grade-row > label {
            cursor: pointer;
            font-size: 14px;
            color: rgba(136, 136, 136, 0.7);
            transition: color 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* LUT name span - always white */
        .radio-option label .lut-name {
            color: var(--fds-text);
            margin-left: 8px;
        }

        /* Selected state - orange for "LUT X" only */
        .radio-option input[type="radio"]:checked + label,
        .current-grade-row input[type="radio"]:checked + label {
            color: rgba(255, 110, 49, 0.9);
            font-weight: 500;
        }

        /* Keep LUT name white even when selected */
        .radio-option input[type="radio"]:checked + label .lut-name {
            color: var(--fds-text);
            font-weight: 400;
        }

        .current-grade-row .inline-dropdown {
            flex: 1;
            max-width: 220px;
            min-width: 0;
            position: relative;
        }

        .current-grade-row .inline-dropdown .fds-dropdown-selected {
            padding: 4px 28px 4px 10px;
            font-size: 13px;
            border-radius: 6px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Dropdown options: fixed width, anchored to right, expands LEFT */
        .current-grade-row .inline-dropdown .fds-dropdown-options {
            position: absolute;
            top: 100%;
            right: 0;
            left: auto;
            width: 320px;
            margin-top: 4px; /* Small gap between button and dropdown */
            border: 2px solid #FF6B35; /* Full border */
            border-radius: 8px; /* Fully rounded corners */
        }

        .current-grade-row .inline-dropdown .fds-dropdown-option {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* First and last options need adjusted corners for the full-border dropdown */
        .current-grade-row .inline-dropdown .fds-dropdown-option:first-child {
            border-radius: 6px 6px 0 0;
        }

        .current-grade-row .inline-dropdown .fds-dropdown-option:last-child {
            border-radius: 0 0 6px 6px;
        }

        /* FDS Custom Dropdown (full control over styling) */
        .fds-custom-dropdown {
            position: relative;
            width: 100%;
        }

        .fds-dropdown-selected {
            width: 100%;
            background: #2a2a2a;
            border: 2px solid #FF6B35; /* Exact FDS orange */
            border-radius: 10px; /* Even more rounded like FDS */
            padding: 8px 32px 8px 12px;
            font-size: 14px;
            color: #ffffff;
            cursor: pointer;
            user-select: none;
            position: relative;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .fds-dropdown-selected:after {
            content: '';
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 6px solid #ffffff;
            transition: transform 0.2s;
        }

        .fds-dropdown-selected.open:after {
            transform: translateY(-50%) rotate(180deg);
        }

        /* CRITICAL: Preserve chevron when tooltip-enabled class is added (overrides .tooltip-enabled::after) */
        .fds-dropdown-selected.tooltip-enabled:after {
            /* Reset tooltip positioning */
            left: auto !important;
            bottom: auto !important;
            border-bottom: none !important;
            border-top-color: #ffffff !important;
            opacity: 1 !important;
        }

        .fds-dropdown-selected:hover {
            background: #353535;
        }

        .fds-dropdown-options {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #2a2a2a;
            border: 2px solid #FF6B35;
            border-top: none;
            border-radius: 0 0 10px 10px; /* Match increased radius */
            margin-top: -2px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .fds-dropdown-option {
            padding: 10px 12px;
            color: #ffffff;
            cursor: pointer;
            transition: background-color 0.15s;
            font-size: 14px;
        }

        .fds-dropdown-option:hover {
            background: #FF6B35; /* Orange highlight on hover */
        }

        .fds-dropdown-option.selected {
            /* Selected item has no background when dropdown is open */
            /* Only hover state shows orange - cleaner UX */
            background: transparent;
            font-weight: 500;
        }

        /* When hovering over the selected item, still show orange */
        .fds-dropdown-option.selected:hover {
            background: #FF6B35;
        }

        /* Scrollbar styling for dropdown */
        .fds-dropdown-options::-webkit-scrollbar {
            width: 8px;
        }

        .fds-dropdown-options::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 0 0 6px 0;
        }

        .fds-dropdown-options::-webkit-scrollbar-thumb {
            background: #FF6B35;
            border-radius: 4px;
        }

        .fds-dropdown-options::-webkit-scrollbar-thumb:hover {
            background: #ff9f2e;
        }

        /* LUT dropdown */
        .lut-option {
            margin-bottom: 12px;
        }

        .lut-option label {
            display: block;
            font-size: 13px;
            color: var(--fds-text-dim);
            margin-bottom: 6px;
        }

        .lut-option select {
            width: 100%;
            padding: 8px 12px;
            background: var(--fds-bg-medium);
            border: 1px solid var(--fds-border);
            border-radius: 4px;
            color: var(--fds-text);
            font-size: 13px;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .lut-option select:hover {
            border-color: var(--fds-orange);
        }

        .lut-option select:focus {
            outline: none;
            border-color: var(--fds-orange);
        }

        .lut-option select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Notes/Feedback */
        .notes-field {
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            flex: 1; /* Both fields expand equally */
            min-height: 0; /* Important for flex */
        }

        .notes-field:last-child {
            margin-bottom: 0;
        }

        .notes-field label {
            display: block;
            font-size: 13px;
            color: var(--fds-text-dim);
            margin-bottom: 8px;
            flex-shrink: 0; /* Don't shrink labels */
        }

        .notes-field textarea {
            width: 100%;
            flex: 1; /* Textarea expands to fill available space in its container */
            min-height: 80px; /* Minimum for usability */
            padding: 12px;
            background: var(--fds-bg-medium);
            border: 1px solid var(--fds-border);
            border-radius: 4px;
            color: var(--fds-text);
            font-size: 14px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; /* System font */
            line-height: 1.5;
            resize: none;
            transition: border-color 0.2s;
            white-space: pre-wrap; /* Preserve spaces and line breaks */
            word-wrap: break-word;
            overflow-y: auto; /* Allow scrolling if needed */
        }

        /* Read-only textarea styling (colorist notes) */
        .notes-field textarea[readonly] {
            background: var(--fds-bg-medium);
            color: var(--fds-text-secondary);
            cursor: default;
        }

        .notes-field textarea[readonly]:focus {
            outline: none;
            border-color: var(--fds-border);
        }

        /* Custom scrollbar styling for textareas - FDS orange */
        .notes-field textarea::-webkit-scrollbar {
            width: 12px;
        }

        .notes-field textarea::-webkit-scrollbar-track {
            background: transparent;
        }

        .notes-field textarea::-webkit-scrollbar-thumb {
            background: var(--fds-orange);
            border-radius: 6px;
            border: 2px solid var(--fds-bg-medium); /* Creates padding effect */
        }

        .notes-field textarea::-webkit-scrollbar-thumb:hover {
            background: #ff9f2e; /* Lighter orange on hover */
        }

        /* Firefox scrollbar styling */
        .notes-field textarea {
            scrollbar-width: thin;
            scrollbar-color: var(--fds-orange) transparent;
        }

        /* Larger min-height on bigger screens */
        @media (min-height: 800px) {
            .notes-field textarea {
                min-height: 150px;
            }
        }

        .notes-field textarea:focus {
            outline: none;
            border-color: var(--fds-orange);
        }

        .notes-field textarea:read-only {
            opacity: 0.7;
            cursor: not-allowed;
        }

        .notes-field textarea::placeholder {
            color: var(--fds-text-dim);
            opacity: 0.5;
        }

        .auto-save-indicator {
            font-size: 11px;
            color: var(--fds-text-dim);
            margin-top: 4px;
            font-style: italic;
        }

        .auto-save-indicator.saved {
            color: #4caf50;
        }

        /* Responsive modal */
        @media (max-width: 1024px) {
            .modal-right {
                width: 380px;
                min-width: 380px;
            }
        }

        /* Mobile devices - force landscape-style layout */
        /* Landscape orientation on mobile - fullscreen image viewer */
        /* Use multiple conditions: orientation + aspect ratio + max-height for comprehensive mobile detection */
        /* This catches iPhone Max, various Android devices, and tablets in landscape */
        @media (orientation: landscape) and (max-height: 500px) {
            .modal-content {
                flex-direction: row;
                width: 100vw;
                /* Use dvh for dynamic viewport height (accounts for Safari browser chrome) */
                height: 100dvh;
                /* Use CSS variable for height - set by JS for accurate mobile viewport */
                height: var(--viewport-height, 100vh);
                max-width: 100vw;
                max-height: var(--viewport-height, 100vh);
                border-radius: 0;
                /* Account for safe areas (notch, home indicator) */
                padding-left: env(safe-area-inset-left);
                padding-right: env(safe-area-inset-right);
            }

            /* Hide right panel in landscape - image only */
            .modal-right {
                display: none !important;
            }

            /* Image takes full width */
            .modal-left {
                flex: 1;
                width: 100%;
                border-radius: 0;
                padding: 10px;
                padding-bottom: env(safe-area-inset-bottom, 10px);
            }

            .modal-image {
                max-width: calc(100vw - 40px - env(safe-area-inset-left) - env(safe-area-inset-right));
                max-height: calc(var(--viewport-height, 100vh) - 80px);
            }

            /* Show TC/Shot info compactly */
            .modal-frame-info {
                padding: 6px 12px;
                padding-bottom: calc(6px + env(safe-area-inset-bottom, 0px));
            }

            .modal-timecode {
                font-size: 12px;
            }

            .modal-shot {
                font-size: 12px;
            }

            .modal-favorite-btn {
                font-size: 24px;
                min-width: 40px;
            }

            /* Navigation arrows - smaller and at outer edges for mobile */
            .nav-arrow {
                width: 40px !important;
                height: 40px !important;
                font-size: 16px !important;
            }

            .nav-arrow.prev {
                left: 4px !important; /* Relative to image container, not viewport */
            }

            .nav-arrow.next {
                right: 4px !important; /* Relative to image container, not viewport */
            }

            .modal-close {
                top: 10px;
                right: calc(10px + env(safe-area-inset-right));
            }

            .modal-fullscreen {
                top: 10px;
                left: calc(10px + env(safe-area-inset-left));
            }
        }

        /* Additional landscape rule for slightly taller mobile landscape (some Android devices) */
        /* Triggered by JS-set class for more accurate detection */
        html.mobile-landscape .modal-content {
            flex-direction: row;
            width: 100vw;
            height: 100dvh;
            height: var(--viewport-height, 100vh);
            max-width: 100vw;
            max-height: var(--viewport-height, 100vh);
            border-radius: 0;
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }

        html.mobile-landscape .modal-right {
            display: none !important;
        }

        html.mobile-landscape .modal-left {
            flex: 1;
            width: 100%;
            border-radius: 0;
            padding: 10px;
            padding-bottom: env(safe-area-inset-bottom, 10px);
        }

        html.mobile-landscape .modal-image {
            max-width: calc(100vw - 40px - env(safe-area-inset-left) - env(safe-area-inset-right));
            max-height: calc(var(--viewport-height, 100vh) - 80px);
        }

        html.mobile-landscape .modal-frame-info {
            padding: 6px 12px;
            padding-bottom: calc(6px + env(safe-area-inset-bottom, 0px));
        }

        html.mobile-landscape .modal-timecode,
        html.mobile-landscape .modal-shot {
            font-size: 12px;
        }

        html.mobile-landscape .modal-favorite-btn {
            font-size: 24px;
            min-width: 40px;
        }

        html.mobile-landscape .nav-arrow {
            width: 40px !important;
            height: 40px !important;
            font-size: 16px !important;
        }

        html.mobile-landscape .nav-arrow.prev {
            left: 4px !important; /* Relative to image container */
        }

        html.mobile-landscape .nav-arrow.next {
            right: 4px !important; /* Relative to image container */
        }

        html.mobile-landscape .modal-close {
            top: 10px;
            right: calc(10px + env(safe-area-inset-right));
        }

        html.mobile-landscape .modal-fullscreen {
            top: 10px;
            left: calc(10px + env(safe-area-inset-left));
        }

        /* Legacy fallback: original max-width based query for older browsers */
        @media (max-width: 900px) and (orientation: landscape) {
            .modal-content {
                flex-direction: row;
                width: 100vw;
                height: 100dvh;
                height: calc(var(--vh, 1vh) * 100);
                max-width: 100vw;
                max-height: calc(var(--vh, 1vh) * 100);
                border-radius: 0;
                padding-left: env(safe-area-inset-left);
                padding-right: env(safe-area-inset-right);
            }

            .modal-right {
                display: none;
            }

            .modal-left {
                flex: 1;
                width: 100%;
                border-radius: 0;
                padding: 10px;
                padding-bottom: env(safe-area-inset-bottom, 10px);
            }

            .modal-image {
                max-width: calc(100vw - 40px - env(safe-area-inset-left) - env(safe-area-inset-right));
                max-height: calc(var(--vh, 1vh) * 100 - 80px);
            }

            .modal-frame-info {
                padding: 6px 12px;
                padding-bottom: calc(6px + env(safe-area-inset-bottom, 0px));
            }

            .modal-timecode {
                font-size: 12px;
            }

            .modal-shot {
                font-size: 12px;
            }

            .modal-favorite-btn {
                font-size: 24px;
                min-width: 40px;
            }

            .nav-arrow {
                width: 40px !important;
                height: 40px !important;
                font-size: 16px !important;
            }

            .nav-arrow.prev {
                left: 4px !important; /* Relative to image container */
            }

            .nav-arrow.next {
                right: 4px !important; /* Relative to image container */
            }

            .modal-close {
                top: 10px;
                right: calc(10px + env(safe-area-inset-right));
            }

            .modal-fullscreen {
                top: 10px;
                left: calc(10px + env(safe-area-inset-left));
            }
        }

        /* Very narrow mobile screens - narrower panel (portrait only now) */
        @media (max-width: 600px) and (orientation: portrait) {
            .modal-right {
                width: 260px;
                min-width: 260px;
            }

            .modal-image {
                max-width: calc(100vw - 280px);
            }

            .modal-section {
                padding: 10px 12px;
            }

            .modal-section-title {
                font-size: 12px;
            }

            .look-option {
                font-size: 12px;
            }
        }

        /* Portrait orientation on mobile - stack vertically */
        @media (max-width: 768px) and (orientation: portrait) {
            .modal-content {
                flex-direction: column;
                width: 100%;
                /* Don't set fixed height - let it size naturally */
                height: auto;
                max-height: none;
                /* Ensure close button is visible */
                padding-top: 0;
            }

            .modal-left {
                flex: none;
                /* Use a percentage of available width for consistent sizing */
                width: 100%;
                height: auto;
                min-height: 200px;
                max-height: 45vh;
            }

            .modal-image {
                max-width: calc(100vw - 32px);
                max-height: 38vh;
                width: auto;
                height: auto;
            }

            /* Mobile navigation arrows - smaller and at outer edges */
            .nav-arrow {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }

            .nav-arrow.prev {
                left: 4px; /* Very close to edge with small padding */
            }

            .nav-arrow.next {
                right: 4px; /* Very close to edge with small padding */
            }

            /* Show metadata pills on mobile portrait */
            .modal-image-overlay {
                display: block;
            }

            /* Scale down TC/Shot info bar */
            .modal-frame-info {
                padding: 8px 12px;
                gap: 8px;
            }

            .modal-frame-meta {
                flex-direction: row;
                flex-wrap: nowrap;
                gap: 6px;
                min-width: 0; /* Allow shrinking */
                overflow: hidden;
            }

            .modal-timecode {
                font-size: 11px;
                white-space: nowrap;
            }

            .modal-shot {
                font-size: 11px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                min-width: 0;
            }

            .modal-favorite-btn {
                font-size: 22px;
                min-width: 36px;
                padding: 4px;
            }

            .modal-right {
                width: 100%;
                min-width: 100%;
                flex: 1;
                border-left: none;
                border-top: 1px solid var(--fds-border);
                max-height: none;
                overflow-y: visible; /* Let parent scroll */
                -webkit-overflow-scrolling: touch;
            }

            /* Ensure notes section is visible and scrollable */
            .modal-section {
                padding: 12px 16px;
            }

            /* Fix notes field spacing - ensure separation */
            .notes-field {
                margin-bottom: 20px;
                flex: none;
            }

            .notes-field:last-child {
                margin-bottom: 0;
            }

            .notes-field textarea {
                min-height: 45px;
                max-height: 70px;
                font-size: 16px; /* 16px prevents iOS auto-zoom on focus */
                flex: none;
            }

            /* Make sure labels are clearly visible */
            .notes-field label {
                font-size: 13px;
                font-weight: 500;
                margin-bottom: 8px;
                color: var(--fds-text-dim);
            }

            /* Close button - ensure visible at top */
            .modal-close {
                position: fixed;
                top: max(8px, env(safe-area-inset-top));
                right: max(8px, env(safe-area-inset-right));
                z-index: 1001;
            }
        }

        /* Very small screens - further optimize */
        @media (max-height: 700px) {
            .notes-field textarea {
                min-height: 50px;
            }

            .modal-section {
                padding: 12px 0;
            }

            .modal-section:first-child {
                padding-top: 12px;
            }
        }

        /* ============================================================
           FOOTER
           ============================================================ */

        .footer {
            background: linear-gradient(to bottom, #252525, #272727 25%, #292929 45%, #2b2b2b 65%, #2e2e2e 85%, #313131);
            border-top: 1px solid var(--fds-border);
            padding: 24px 40px;
            text-align: center;
            color: var(--fds-text-dim);
            font-size: 13px;
        }

        .footer-brand {
            font-weight: 500;
            color: var(--fds-text);
        }

        .footer-hint {
            margin-top: 8px;
            font-size: 12px;
            opacity: 0.7;
        }

        /* ============================================================
           UTILITY CLASSES
           ============================================================ */

        .hidden {
            display: none !important;
        }

        /* Loading state */
        .loading {
            text-align: center;
            padding: 40px;
            color: var(--fds-text-dim);
        }

        .loading::after {
            content: '...';
            animation: loading 1.5s infinite;
        }

        @keyframes loading {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <!-- Filter/Sort Controls - left side (desktop only) -->
            <div class="header-left">
                <div class="filter-sort-container" id="filterSortContainer">
                    <div class="filter-dropdown" id="filterDropdown">
                        <button class="filter-dropdown-btn" id="filterDropdownBtn">
                            Show: All Frames
                        </button>
                    </div>
                    <button class="filter-reset-btn hidden" id="filterResetBtn" title="Reset to defaults">
                        ✕ Reset
                    </button>
                </div>
            </div>

            <div class="project-info">
                <h1 class="project-title" id="projectTitle">TestStillDiego</h1>
                <p class="project-subtitle" id="projectSubtitle">DoP</p>
            </div>

            <!-- Mobile hamburger menu button (right side) - triggers same dropdown as desktop -->
            <button class="mobile-menu-btn" id="mobileMenuBtn" aria-label="Menu">☰</button>

            <!-- Filter dropdown menu (outside header-left so it's visible on mobile) -->
            <div class="filter-dropdown-menu" id="filterDropdownMenu">
                <!-- Filter Section -->
                <div class="filter-dropdown-section">
                    <div class="filter-dropdown-section-title">Filter</div>
                    <div class="filter-dropdown-item active" data-filter="all">
                        <span class="item-icon">📋</span>
                        <span>All Frames</span>
                        <span class="item-count" id="countAll">0</span>
                    </div>
                    <div class="filter-dropdown-item" data-filter="favorites">
                        <span class="item-icon">⭐</span>
                        <span>Favorites Only</span>
                        <span class="item-count" id="countFavorites">0</span>
                    </div>
                    <div class="filter-dropdown-item" data-filter="has-notes">
                        <span class="item-icon">💬</span>
                        <span>With Any Notes</span>
                        <span class="item-count" id="countNotes">0</span>
                    </div>
                    <div class="filter-dropdown-item" data-filter="has-client-feedback">
                        <span class="item-icon">📝</span>
                        <span>With Client Feedback</span>
                        <span class="item-count" id="countClientFeedback">0</span>
                    </div>
                </div>
                <!-- Sort Section -->
                <div class="filter-dropdown-section">
                    <div class="filter-dropdown-section-title">Sort</div>
                    <div class="filter-dropdown-item active" data-sort="timeline">
                        <span class="item-icon">🎬</span>
                        <span>Timeline Order</span>
                    </div>
                    <div class="filter-dropdown-item" data-sort="favorites-first">
                        <span class="item-icon">⭐</span>
                        <span>Favorites First</span>
                    </div>
                    <div class="filter-dropdown-item" data-sort="notes-first">
                        <span class="item-icon">💬</span>
                        <span>With Notes First</span>
                    </div>
                </div>
            </div>

            <div class="header-controls">
                <div class="header-controls-row">
                    <div class="grid-size-selector">
                        <button class="grid-btn " data-grid="2x2">2×2</button>
                    <button class="grid-btn active" data-grid="3x3">3×3</button>
                    <button class="grid-btn " data-grid="4x4">4×4</button>
                    </div>
                    <div class="thumb-size-selector">
                        <button class="thumb-btn " data-size="medium">M</button>
                    <button class="thumb-btn active" data-size="large">L</button>
                    <button class="thumb-btn " data-size="max">XL</button>
                    </div>
                </div>
                <div class="frame-counter" id="frameCounter">3 frames</div>
            </div>
        </div>
    </header>

    

    <!-- Grid Container -->
    <main class="grid-container">
        <div class="contact-sheet-grid grid-3x3" id="contactSheetGrid">
            <!-- Thumbnail cards will be generated by JavaScript -->
            <div class="loading">Loading contact sheet</div>
        </div>
    </main>

    <!-- Modal Viewer -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal-content">
            <!-- Close Button -->
            <button class="modal-close" id="modalClose" aria-label="Close">×</button>

            <!-- Fullscreen Button (for Android/desktop - hidden on iOS which has native fullscreen) -->
            <button class="modal-fullscreen" id="modalFullscreen" aria-label="Toggle fullscreen" title="Toggle fullscreen">⛶</button>

            <!-- Left Panel - Image Viewer -->
            <div class="modal-left">
                <div class="modal-image-wrapper">
                    <div class="modal-image-container">
                        <img class="modal-image" id="modalImage" src="" alt="Frame preview">

                        <!-- Metadata overlay pills -->
                        <div class="modal-image-overlay" id="modalImageOverlay"></div>

                        <!-- Frame counter (centered at bottom of image) -->
                        <div class="modal-frame-counter" id="modalFrameCounter">0 / 0</div>

                        <!-- Navigation arrows -->
                        <button class="nav-arrow prev" id="navPrev" aria-label="Previous frame">◀</button>
                        <button class="nav-arrow next" id="navNext" aria-label="Next frame">▶</button>
                    </div>
                </div>

                <!-- Frame info bar -->
                <div class="modal-frame-info">
                    <div class="modal-frame-meta">
                        <div class="modal-timecode" id="modalTimecode">TC: 00:00:00:00</div>
                        <div class="modal-shot" id="modalShot">Shot: â€”</div>
                    </div>
                    <button class="modal-favorite-btn tooltip-enabled" id="modalFavoriteBtn" aria-label="Toggle favorite" data-tooltip="Mark as favorite"></button>
                </div>
            </div>

            <!-- Right Panel - Controls -->
            <div class="modal-right">
                <!-- View Mode Section -->
                <div class="modal-section">
                    <h3 class="modal-section-title">Look Options</h3>
                    <div class="radio-group">
                        <!-- Current Grade with inline dropdown -->
                        <div id="currentGradeOption" class="current-grade-row">
                            <input type="radio" name="viewMode" id="viewGraded" value="current_grade" checked>
                            <label for="viewGraded">Current Grade</label>
                            <!-- Inline Grade Version Dropdown -->
                            <div id="versionDropdownContainer" class="inline-dropdown" style="display: none;">
                                <div class="fds-custom-dropdown" id="customDropdown">
                                    <div class="fds-dropdown-selected" id="dropdownSelected">
                                        Version 1 ⭐
                                    </div>
                                    <div class="fds-dropdown-options" id="dropdownOptions" style="display: none;">
                                        <!-- Options populated dynamically -->
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- No Grade (conditionally shown) -->
                        <div id="noGradeOption" class="radio-option">
                            <input type="radio" name="viewMode" id="viewUngraded" value="no_grade">
                            <label for="viewUngraded" title="Shows frame's RAW-interpreted baseline. This is after Camera RAW settings but BEFORE any creative color grading nodes.">No Grade</label>
                        </div>

                        <!-- LUT 1-4 (conditionally shown with proper radio inputs) -->
                        <div id="lut1Option" class="radio-option" style="display: none;">
                            <input type="radio" name="viewMode" id="viewLut1" value="lut_1">
                            <label for="viewLut1" id="lut1Label" title="">LUT 1</label>
                        </div>

                        <div id="lut2Option" class="radio-option" style="display: none;">
                            <input type="radio" name="viewMode" id="viewLut2" value="lut_2">
                            <label for="viewLut2" id="lut2Label" title="">LUT 2</label>
                        </div>

                        <div id="lut3Option" class="radio-option" style="display: none;">
                            <input type="radio" name="viewMode" id="viewLut3" value="lut_3">
                            <label for="viewLut3" id="lut3Label" title="">LUT 3</label>
                        </div>

                        <div id="lut4Option" class="radio-option" style="display: none;">
                            <input type="radio" name="viewMode" id="viewLut4" value="lut_4">
                            <label for="viewLut4" id="lut4Label" title="">LUT 4</label>
                        </div>
                    </div>
                </div>

                <!-- LUT Previews Section -->
                <div class="modal-section" id="lutPreviewSection" style="display: none;">
                    <h3 class="modal-section-title">LUT Previews</h3>
                    <p style="font-size: 12px; color: var(--fds-text-dim); margin-bottom: 12px;">
                        Apply to ungraded source
                    </p>
                    <div class="lut-option">
                        <label for="lutSelect1">LUT 1</label>
                        <select id="lutSelect1" disabled>
                            <option value="">(Select LUT)</option>
                        </select>
                    </div>
                    <div class="lut-option">
                        <label for="lutSelect2">LUT 2</label>
                        <select id="lutSelect2" disabled>
                            <option value="">(Select LUT)</option>
                        </select>
                    </div>
                    <div class="lut-option">
                        <label for="lutSelect3">LUT 3</label>
                        <select id="lutSelect3" disabled>
                            <option value="">(Select LUT)</option>
                        </select>
                    </div>
                    <div class="lut-option">
                        <label for="lutSelect4">LUT 4</label>
                        <select id="lutSelect4" disabled>
                            <option value="">(Select LUT)</option>
                        </select>
                    </div>
                </div>

                <!-- Notes & Feedback Section -->
                <div class="modal-section">
                    <h3 class="modal-section-title">Notes & Feedback</h3>

                    <div class="notes-field">
                        <label for="coloristNotes">📝 From Colorist</label>
                        <textarea id="coloristNotes" placeholder="(No notes from colorist)"></textarea>
                    </div>

                    <div class="notes-field" id="clientFeedbackContainer">
                        <label for="clientFeedback">💬 Your Feedback</label>
                        <textarea id="clientFeedback" placeholder="Add your feedback here..."></textarea>
                        <div class="auto-save-indicator" id="autoSaveIndicator"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Download Section (shown above footer when enabled) -->
    <div class="mobile-download-container"><a href="TestStillDiego_Photos.zip" class="download-all-btn" download>⬇ Download Photos</a></div>

    <!-- Footer -->
    <footer class="footer">
        <div><span class="footer-brand">Generated by FrameDeck Studio</span> | 2026-02-24 11:56:45</div>
        <div class="footer-hint">Click any frame to open detailed view • Use arrow keys to navigate</div>
    </footer>

    <script>
        // ====================================================================
        // FRAMEDECK STUDIO INTERACTIVE CONTACT SHEET
        // Grid View Implementation
        // ====================================================================

        // Sample frame data (will be replaced with real data from FDS export)
        const FRAME_DATA = {
    '86400': {
        timecode: '01:00:00:00',
        shot: 'A002C012_220622VN.mxf',
        thumbnail_url: 'thumbnails/frame_86400_1.1.1.jpg',
        graded_url: 'fullsize/frame_86400_1.1.1.jpg',
        ungraded_url: 'fullsize/ungraded_frame_86400.jpg',
        ungraded_lut_url: '',
        versions: [{display_name: "1.1.1", image_url: "fullsize/frame_86400_1.1.1.jpg", is_active: true}],
        favorite: false,
        pill_positions: {
            'Clip Name: A002C012_220622VN.mxf': 'bottom-left'
        },
        notes: {
            colorist: '',
            client: ''
        }
    },
    '86640': {
        timecode: '01:00:10:00',
        shot: 'A002C013_220622SK.mxf',
        thumbnail_url: 'thumbnails/frame_86640_1.2.1.jpg',
        graded_url: 'fullsize/frame_86640_1.2.1.jpg',
        ungraded_url: 'fullsize/ungraded_frame_86640.jpg',
        ungraded_lut_url: '',
        versions: [{display_name: "1.2.1", image_url: "fullsize/frame_86640_1.2.1.jpg", is_active: true}],
        favorite: false,
        pill_positions: {
            'Clip Name: A002C013_220622SK.mxf': 'bottom-left'
        },
        notes: {
            colorist: '',
            client: ''
        }
    },
    '86880': {
        timecode: '01:00:20:00',
        shot: 'A002C015_2206222J.mxf',
        thumbnail_url: 'thumbnails/frame_86880_1.3.1.jpg',
        graded_url: 'fullsize/frame_86880_1.3.1.jpg',
        ungraded_url: 'fullsize/ungraded_frame_86880.jpg',
        ungraded_lut_url: '',
        versions: [{display_name: "1.3.1", image_url: "fullsize/frame_86880_1.3.1.jpg", is_active: true}],
        favorite: false,
        pill_positions: {
            'Clip Name: A002C015_2206222J.mxf': 'bottom-left'
        },
        notes: {
            colorist: '',
            client: ''
        }
    }
};

        // ====================================================================
        // GENERATION ID - Prevents localStorage from persisting across generations
        // ====================================================================
        const GENERATION_ID = '20260224_115645';

        // ====================================================================
        // DISPLAY SETTINGS
        // ====================================================================
        const SHOW_TC_INFO = true;  // Whether to show TC/Shot info
        const HAS_UNGRADED = true;  // Whether ungraded frames are available

        // ====================================================================
        // LUT CONFIGURATION - Exported from Client Review settings
        // ====================================================================
        const LUT_CONFIG = {"include_current_grade": true, "include_no_grade": true, "lut_1_enabled": false, "lut_1_default": "IPS_LMT_A", "lut_2_enabled": false, "lut_2_default": "(Select LUT)", "lut_3_enabled": false, "lut_3_default": "(Select LUT)", "lut_4_enabled": false, "lut_4_default": "(Select LUT)"};

        // ====================================================================
        // LUT FILES - Base64 encoded .cube files for browser-based LUT application
        // ====================================================================
        const LUT_FILES = {};

        // ====================================================================
        // FIREBASE CONFIG - For cross-device notes synchronization
        // ====================================================================
        const FIREBASE_CONFIG = null;
        const GALLERY_ID = '';

        // ====================================================================
        // REVIEW BORDERS CONFIG - Enable/disable review status borders
        // ====================================================================
        const ENABLE_REVIEW_BORDERS = false;

        // ====================================================================
        // FRAME CUSTOM LOOKS - Per-frame overrides (only frames with custom settings)
        // Frames not listed here use global LUT_CONFIG
        // ====================================================================
        const FRAME_CUSTOM_LOOKS = {};

        // ====================================================================
        // FILTER/SORT STATE
        // ====================================================================
        let currentFilter = 'all';
        let currentSort = 'timeline';
        let originalFrameOrder = []; // Store original timeline order

        /**
         * Get LUT config for a specific frame, merging global with custom overrides
         */
        function getFrameLUTConfig(frameId) {
            if (FRAME_CUSTOM_LOOKS && FRAME_CUSTOM_LOOKS[frameId]) {
                return { ...LUT_CONFIG, ...FRAME_CUSTOM_LOOKS[frameId] };
            }
            return LUT_CONFIG;
        }

        // ====================================================================
        // FIREBASE INITIALIZATION - For cross-device notes sync
        // ====================================================================
        let firebaseDb = null;
        let notesRef = null;
        let favoritesRef = null;
        let reviewedRef = null;

        function initFirebase() {
            if (!FIREBASE_CONFIG || !FIREBASE_CONFIG.apiKey) {
                console.log('[ContactSheet] Firebase not configured, using local storage only');
                // Hide client feedback section since it won't sync anywhere
                document.querySelector('.modal-right')?.classList.add('no-firebase');
                // Make colorist notes read-only (no two-way sync without Firebase)
                const coloristNotes = document.getElementById('coloristNotes');
                if (coloristNotes) {
                    coloristNotes.setAttribute('readonly', true);
                }
                console.log('[ContactSheet] No Firebase - colorist notes readonly, client feedback hidden');
                return false;
            }

            try {
                // Initialize Firebase
                if (!firebase.apps.length) {
                    firebase.initializeApp(FIREBASE_CONFIG);
                }
                firebaseDb = firebase.database();
                notesRef = firebaseDb.ref(`galleries/${GALLERY_ID}/notes`);
                favoritesRef = firebaseDb.ref(`galleries/${GALLERY_ID}/favorites`);
                reviewedRef = firebaseDb.ref(`galleries/${GALLERY_ID}/reviewed`);

                console.log('[ContactSheet] Firebase initialized for gallery:', GALLERY_ID);

                // Listen for real-time notes updates
                notesRef.on('value', (snapshot) => {
                    const notes = snapshot.val() || {};
                    console.log('[ContactSheet] Received notes update from Firebase');

                    // Update FRAME_DATA with latest notes
                    Object.keys(notes).forEach(frameId => {
                        if (FRAME_DATA[frameId]) {
                            FRAME_DATA[frameId].notes = {
                                ...FRAME_DATA[frameId].notes,
                                ...notes[frameId]
                            };
                        }
                    });

                    // If modal is open, refresh the notes display
                    if (selectedFrameId && FRAME_DATA[selectedFrameId]) {
                        const coloristNotesEl = document.getElementById('coloristNotes');
                        const clientFeedbackEl = document.getElementById('clientFeedback');
                        if (coloristNotesEl && notes[selectedFrameId]) {
                            coloristNotesEl.value = notes[selectedFrameId].colorist || coloristNotesEl.value;
                        }
                        if (clientFeedbackEl && notes[selectedFrameId]) {
                            clientFeedbackEl.value = notes[selectedFrameId].client || clientFeedbackEl.value;
                        }
                    }

                    // Update feedback badges on thumbnail cards
                    updateFeedbackBadges();
                });

                // Listen for real-time favorites updates
                favoritesRef.on('value', (snapshot) => {
                    const favorites = snapshot.val() || {};
                    console.log('[ContactSheet] Received favorites update from Firebase');

                    // Update FRAME_DATA with latest favorites
                    // Only override if Firebase has explicit data for this frame
                    Object.keys(FRAME_DATA).forEach(frameId => {
                        const wasFavorite = FRAME_DATA[frameId].favorite;
                        // Only update if Firebase has explicit true/false for this frame
                        // Otherwise preserve the initial state from colorist
                        const hasFirebaseValue = frameId in favorites;
                        const isFavorite = hasFirebaseValue ? (favorites[frameId] === true) : wasFavorite;

                        if (wasFavorite !== isFavorite) {
                            FRAME_DATA[frameId].favorite = isFavorite;

                            // Update grid card badge and border
                            const card = document.querySelector(`[data-frame-id="${frameId}"]`);
                            if (card) {
                                // Toggle favorited class for orange border
                                card.classList.toggle('favorited', isFavorite);

                                const badge = card.querySelector('.favorite-badge');
                                if (isFavorite && !badge) {
                                    const container = card.querySelector('.thumbnail-image-container');
                                    const newBadge = document.createElement('div');
                                    newBadge.className = 'favorite-badge';
                                    newBadge.textContent = '★';
                                    container.appendChild(newBadge);
                                } else if (!isFavorite && badge) {
                                    badge.remove();
                                }
                            }
                        }
                    });

                    // If modal is open, update the favorite button
                    if (selectedFrameId && FRAME_DATA[selectedFrameId]) {
                        const favBtn = document.getElementById('modalFavoriteBtn');
                        if (favBtn) {
                            favBtn.classList.toggle('active', FRAME_DATA[selectedFrameId].favorite);
                        }
                    }

                    // Update filter counts when favorites change
                    updateFilterCounts();
                });

                // Listen for real-time reviewed state updates (only if enabled)
                if (ENABLE_REVIEW_BORDERS) {
                    reviewedRef.on('value', (snapshot) => {
                        const reviewed = snapshot.val() || {};
                        console.log('[ContactSheet] Received reviewed update from Firebase');

                        // Update FRAME_DATA and card borders with latest reviewed states
                        Object.keys(FRAME_DATA).forEach(frameId => {
                            const wasReviewed = FRAME_DATA[frameId].reviewed || false;
                            const isReviewed = reviewed[frameId] === true;

                            if (wasReviewed !== isReviewed) {
                                FRAME_DATA[frameId].reviewed = isReviewed;

                                // Update grid card border
                                const card = document.querySelector(`[data-frame-id="${frameId}"]`);
                                if (card) {
                                    card.classList.toggle('reviewed', isReviewed);
                                }
                            }
                        });

                        // Update frame counter when reviewed state changes from another device
                        updateFrameCounter();
                    });
                }

                return true;
            } catch (e) {
                console.error('[ContactSheet] Firebase init error:', e);
                return false;
            }
        }

        // Check if this is a new generation and clear old localStorage
        const lastGenerationId = localStorage.getItem('generation_id');
        if (lastGenerationId !== GENERATION_ID) {
            console.log(`[ContactSheet] New generation detected (${GENERATION_ID}), clearing old localStorage`);
            // Clear all contact sheet data from previous generation
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && (key.startsWith('feedback_') || key.startsWith('colorist_notes_') || key === 'favorites' || key === 'reviewed')) {
                    keysToRemove.push(key);
                }
            }
            keysToRemove.forEach(key => localStorage.removeItem(key));
            // Store new generation ID
            localStorage.setItem('generation_id', GENERATION_ID);
            console.log(`[ContactSheet] Cleared ${keysToRemove.length} old localStorage entries`);
        } else {
            console.log(`[ContactSheet] Same generation (${GENERATION_ID}), keeping localStorage data`);
        }

        // Global state
        let currentGridSize = '3x3';
        let selectedFrameId = null;

        // Persistent dropdown selections per frame
        // Tracks which version is selected for each frame across navigation
        const frameDropdownSelections = {};

        // Global last viewed mode - persists across navigation (Option 2)
        // Will fall back to available option if current mode not available for frame
        let lastViewedMode = 'current_grade';

        // ====================================================================
        // INITIALIZATION
        // ====================================================================

        document.addEventListener('DOMContentLoaded', () => {
            detectPlatform();  // Detect iOS/Android for platform-specific features
            applyUngradedMode(); // Apply photo gallery mode if no ungraded frames
            initFirebase();  // Initialize Firebase for real-time notes sync
            initializeLUTSystem();  // Initialize LUT engine with embedded .cube files
            initializeContactSheet();
            setupEventListeners();
            initFilterSort();  // Initialize filter/sort controls
            setupImageRepaintHandler(); // Fix backdrop-filter color bleed
            setupOrientationHandler(); // Handle orientation changes on mobile
            setupFullscreenHandler(); // Setup fullscreen button for Android
        });

        // Apply no-ungraded mode (photo gallery mode) if ungraded frames not available
        function applyUngradedMode() {
            if (!HAS_UNGRADED) {
                document.querySelector('.modal-right').classList.add('no-ungraded');
                console.log('[ContactSheet] Photo gallery mode - look options hidden');
            }
        }

        // Detect platform (iOS vs Android) for platform-specific UI
        function detectPlatform() {
            const ua = navigator.userAgent || navigator.vendor || window.opera;
            const isIOS = /iPad|iPhone|iPod/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            const isAndroid = /android/i.test(ua);

            if (isIOS) {
                document.documentElement.classList.add('is-ios');
                console.log('[Platform] Detected iOS');
            } else if (isAndroid) {
                document.documentElement.classList.add('is-android');
                console.log('[Platform] Detected Android');
            }

            // Also detect if Fullscreen API is available
            const fullscreenAvailable = document.documentElement.requestFullscreen ||
                                        document.documentElement.webkitRequestFullscreen ||
                                        document.documentElement.mozRequestFullScreen ||
                                        document.documentElement.msRequestFullscreen;
            if (fullscreenAvailable) {
                document.documentElement.classList.add('fullscreen-available');
                console.log('[Platform] Fullscreen API available');
            }
        }

        // Setup fullscreen button handler
        function setupFullscreenHandler() {
            const fullscreenBtn = document.getElementById('modalFullscreen');
            if (!fullscreenBtn) return;

            fullscreenBtn.addEventListener('click', toggleFullscreen);

            // Listen for fullscreen change events to update button state
            document.addEventListener('fullscreenchange', updateFullscreenButton);
            document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
            document.addEventListener('mozfullscreenchange', updateFullscreenButton);
            document.addEventListener('MSFullscreenChange', updateFullscreenButton);
        }

        function toggleFullscreen() {
            const modalOverlay = document.getElementById('modalOverlay');
            const elem = modalOverlay || document.documentElement;

            if (!document.fullscreenElement && !document.webkitFullscreenElement &&
                !document.mozFullScreenElement && !document.msFullscreenElement) {
                // Enter fullscreen
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen();
                } else if (elem.mozRequestFullScreen) {
                    elem.mozRequestFullScreen();
                } else if (elem.msRequestFullscreen) {
                    elem.msRequestFullscreen();
                }
                modalOverlay.classList.add('fullscreen-mode');
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
                modalOverlay.classList.remove('fullscreen-mode');
            }
        }

        function updateFullscreenButton() {
            const fullscreenBtn = document.getElementById('modalFullscreen');
            const modalOverlay = document.getElementById('modalOverlay');
            if (!fullscreenBtn) return;

            const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement ||
                                document.mozFullScreenElement || document.msFullscreenElement;

            fullscreenBtn.classList.toggle('active', !!isFullscreen);
            fullscreenBtn.textContent = isFullscreen ? '⛶' : '⛶'; // Could use different icons
            fullscreenBtn.title = isFullscreen ? 'Exit fullscreen' : 'Enter fullscreen';

            if (isFullscreen) {
                modalOverlay.classList.add('fullscreen-mode');
            } else {
                modalOverlay.classList.remove('fullscreen-mode');
            }

            // Recalculate image dimensions after fullscreen change
            if (selectedFrameId) {
                setTimeout(() => loadModalFrame(selectedFrameId), 100);
                setTimeout(() => loadModalFrame(selectedFrameId), 300);
            }
        }

        // Handle orientation changes - recalculate image dimensions
        function setupOrientationHandler() {
            let resizeTimeout;
            let lastOrientation = window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
            let lastHeight = window.innerHeight;
            let lastWidth = window.innerWidth;

            const handleOrientationChange = () => {
                const currentOrientation = window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
                const orientationChanged = currentOrientation !== lastOrientation;
                const significantResize = Math.abs(window.innerHeight - lastHeight) > 50 ||
                                         Math.abs(window.innerWidth - lastWidth) > 50;

                lastOrientation = currentOrientation;
                lastHeight = window.innerHeight;
                lastWidth = window.innerWidth;

                // Debounce to avoid multiple recalculations
                clearTimeout(resizeTimeout);

                // If modal is open, reload current frame to recalculate dimensions
                const modalOverlay = document.getElementById('modalOverlay');
                if (modalOverlay && modalOverlay.classList.contains('active') && modalFrameIndex >= 0) {
                    const frameIds = Object.keys(FRAME_DATA);
                    const frameId = frameIds[modalFrameIndex];

                    if ((orientationChanged || significantResize) && frameId) {
                        // For orientation changes, do multiple recalculations as Safari/Android settles
                        // Clear any locked dimensions first to let CSS take over
                        const modalImage = document.getElementById('modalImage');
                        modalImage.style.width = '';
                        modalImage.style.height = '';

                        // Progressive recalculations - more for Android which can be slower
                        setTimeout(() => loadModalFrame(frameId), 50);
                        setTimeout(() => loadModalFrame(frameId), 150);
                        setTimeout(() => loadModalFrame(frameId), 300);
                        setTimeout(() => loadModalFrame(frameId), 500);
                        setTimeout(() => loadModalFrame(frameId), 800);
                    } else if (frameId) {
                        // Regular resize - single recalculation
                        resizeTimeout = setTimeout(() => loadModalFrame(frameId), 150);
                    }
                }
            };

            // Listen for orientation change and resize
            window.addEventListener('orientationchange', () => {
                // Safari/Android needs extra time after orientationchange event
                setTimeout(handleOrientationChange, 50);
                setTimeout(handleOrientationChange, 150);
            });
            window.addEventListener('resize', handleOrientationChange);

            // Also listen to visualViewport resize (more reliable on iOS Safari and Android Chrome)
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', handleOrientationChange);
            }
        }

        // Swipe navigation for modal
        function setupSwipeNavigation() {
            let startX = 0, valid = false;
            const modal = document.querySelector('.modal-left');

            modal.addEventListener('touchstart', e => {
                valid = !e.target.closest('button, input, textarea');
                startX = e.touches[0].clientX;
            }, {passive: true});

            modal.addEventListener('touchend', e => {
                if (!valid) return;
                const delta = e.changedTouches[0].clientX - startX;
                if (Math.abs(delta) > 50) delta > 0 ? navigateToPrevFrame() : navigateToNextFrame();
            }, {passive: true});
        }

        // Force repaint of metadata overlay when image changes
        // This fixes backdrop-filter caching issue causing color bleed
        function setupImageRepaintHandler() {
            const modalImage = document.getElementById('modalImage');
            const overlay = document.getElementById('modalImageOverlay');

            if (modalImage && overlay) {
                modalImage.addEventListener('load', () => {
                    // Force browser to repaint the overlay by toggling display
                    overlay.style.display = 'none';
                    overlay.offsetHeight; // Trigger reflow
                    overlay.style.display = '';
                });
            }
        }

        function initializeContactSheet() {
            // Load favorites and reviewed states from localStorage
            loadFavoritesFromStorage();
            loadReviewedFromStorage();

            const frameIds = Object.keys(FRAME_DATA);
            const frameCount = frameIds.length;

            // Update frame counter (initial)
            updateFrameCounter();

            // Render grid
            renderGrid(frameIds);

            // Store original frame order for sorting
            originalFrameOrder = frameIds.slice();

            // Initialize feedback badges
            updateFeedbackBadges();
        }

        // Update the frame counter text based on review borders setting
        function updateFrameCounter() {
            const frameIds = Object.keys(FRAME_DATA);
            const frameCount = frameIds.length;

            if (ENABLE_REVIEW_BORDERS) {
                // Count reviewed frames
                const reviewedCount = frameIds.filter(fid => FRAME_DATA[fid].reviewed).length;
                document.getElementById('frameCounter').textContent = `${reviewedCount} of ${frameCount} reviewed`;
            } else {
                document.getElementById('frameCounter').textContent = `${frameCount} frame${frameCount !== 1 ? 's' : ''}`;
            }
        }

        // ====================================================================
        // FEEDBACK BADGES
        // ====================================================================

        /**
         * Update feedback badges on all thumbnail cards based on current notes data
         * Called when Firebase notes are received or on initial load
         */
        function updateFeedbackBadges() {
            const cards = document.querySelectorAll('.thumbnail-card');

            cards.forEach(card => {
                const frameId = card.dataset.frameId;
                const frameData = FRAME_DATA[frameId];
                if (!frameData) return;

                const notes = frameData.notes || {};
                const hasColorist = !!(notes.colorist && notes.colorist.trim());
                const hasClient = !!(notes.client && notes.client.trim());

                // Find or create badge element
                let badge = card.querySelector('.feedback-badge');
                const container = card.querySelector('.thumbnail-image-container');

                if (!badge && container) {
                    badge = document.createElement('div');
                    badge.className = 'feedback-badge';
                    container.appendChild(badge);
                }

                if (badge) {
                    // Reset classes
                    badge.classList.remove('visible', 'has-colorist', 'has-client', 'has-both');

                    if (hasClient && hasColorist) {
                        // Both - show combined
                        badge.classList.add('visible', 'has-both');
                        badge.innerHTML = '📝💬';
                        badge.title = 'Has colorist notes and client feedback';
                    } else if (hasClient) {
                        // Client feedback only - prominent
                        badge.classList.add('visible', 'has-client');
                        badge.innerHTML = '💬';
                        badge.title = 'Has client feedback';
                    } else if (hasColorist) {
                        // Colorist notes only - subtle
                        badge.classList.add('visible', 'has-colorist');
                        badge.innerHTML = '📝';
                        badge.title = 'Has colorist notes';
                    }
                }
            });

            // Update filter counts after badge update
            updateFilterCounts();
        }

        // ====================================================================
        // FILTER/SORT FUNCTIONALITY
        // ====================================================================

        /**
         * Update the counts shown in filter dropdown
         */
        function updateFilterCounts() {
            const frameIds = Object.keys(FRAME_DATA);
            const total = frameIds.length;

            let favoritesCount = 0;
            let notesCount = 0;
            let clientFeedbackCount = 0;

            frameIds.forEach(frameId => {
                const frame = FRAME_DATA[frameId];
                const notes = frame.notes || {};

                if (frame.favorite) favoritesCount++;
                if ((notes.colorist && notes.colorist.trim()) || (notes.client && notes.client.trim())) {
                    notesCount++;
                }
                if (notes.client && notes.client.trim()) clientFeedbackCount++;
            });

            // Update count badges in dropdown
            const countAll = document.getElementById('countAll');
            const countFavorites = document.getElementById('countFavorites');
            const countNotes = document.getElementById('countNotes');
            const countClientFeedback = document.getElementById('countClientFeedback');

            if (countAll) countAll.textContent = total;
            if (countFavorites) countFavorites.textContent = favoritesCount;
            if (countNotes) countNotes.textContent = notesCount;
            if (countClientFeedback) countClientFeedback.textContent = clientFeedbackCount;
        }

        /**
         * Apply current filter - show/hide cards based on criteria
         */
        function applyFilter() {
            const cards = document.querySelectorAll('.thumbnail-card');
            let visibleCount = 0;

            cards.forEach(card => {
                const frameId = card.dataset.frameId;
                const frame = FRAME_DATA[frameId];
                if (!frame) return;

                const notes = frame.notes || {};
                const hasColorist = !!(notes.colorist && notes.colorist.trim());
                const hasClient = !!(notes.client && notes.client.trim());
                const hasAnyNotes = hasColorist || hasClient;

                let shouldShow = true;

                switch (currentFilter) {
                    case 'all':
                        shouldShow = true;
                        break;
                    case 'favorites':
                        shouldShow = frame.favorite === true;
                        break;
                    case 'has-notes':
                        shouldShow = hasAnyNotes;
                        break;
                    case 'has-client-feedback':
                        shouldShow = hasClient;
                        break;
                }

                card.style.display = shouldShow ? '' : 'none';
                if (shouldShow) visibleCount++;
            });

            // Update frame counter to show filtered count
            const frameCounter = document.getElementById('frameCounter');
            const totalCount = Object.keys(FRAME_DATA).length;

            if (currentFilter === 'all') {
                if (ENABLE_REVIEW_BORDERS) {
                    const reviewedCount = Object.keys(FRAME_DATA).filter(fid => FRAME_DATA[fid].reviewed).length;
                    frameCounter.textContent = `${reviewedCount} of ${totalCount} reviewed`;
                } else {
                    frameCounter.textContent = `${totalCount} frame${totalCount !== 1 ? 's' : ''}`;
                }
            } else {
                frameCounter.textContent = `Showing ${visibleCount} of ${totalCount}`;
            }
        }

        /**
         * Apply current sort - reorder cards in DOM
         */
        function applySort() {
            const grid = document.getElementById('contactSheetGrid');
            const cards = Array.from(grid.querySelectorAll('.thumbnail-card'));

            // Store original order on first call
            if (originalFrameOrder.length === 0) {
                originalFrameOrder = cards.map(card => card.dataset.frameId);
            }

            // Sort cards based on current sort mode
            cards.sort((a, b) => {
                const frameA = FRAME_DATA[a.dataset.frameId];
                const frameB = FRAME_DATA[b.dataset.frameId];
                const notesA = frameA?.notes || {};
                const notesB = frameB?.notes || {};

                switch (currentSort) {
                    case 'timeline':
                        // Restore original timeline order
                        return originalFrameOrder.indexOf(a.dataset.frameId) - originalFrameOrder.indexOf(b.dataset.frameId);

                    case 'favorites-first':
                        // Favorites at top, then timeline order
                        if (frameA?.favorite && !frameB?.favorite) return -1;
                        if (!frameA?.favorite && frameB?.favorite) return 1;
                        return originalFrameOrder.indexOf(a.dataset.frameId) - originalFrameOrder.indexOf(b.dataset.frameId);

                    case 'notes-first':
                        // Frames with any notes at top, then timeline order
                        const hasNotesA = !!(notesA.colorist?.trim() || notesA.client?.trim());
                        const hasNotesB = !!(notesB.colorist?.trim() || notesB.client?.trim());
                        if (hasNotesA && !hasNotesB) return -1;
                        if (!hasNotesA && hasNotesB) return 1;
                        return originalFrameOrder.indexOf(a.dataset.frameId) - originalFrameOrder.indexOf(b.dataset.frameId);

                    default:
                        return 0;
                }
            });

            // Re-append cards in new order (this reorders them in DOM)
            cards.forEach(card => grid.appendChild(card));
        }

        /**
         * Set filter and update UI
         */
        function setFilter(filter) {
            currentFilter = filter;

            // Update dropdown button text
            const btn = document.getElementById('filterDropdownBtn');
            const filterTexts = {
                'all': 'Show: All Frames',
                'favorites': 'Show: ⭐ Favorites',
                'has-notes': 'Show: 💬 With Notes',
                'has-client-feedback': 'Show: 📝 Client Feedback'
            };
            btn.textContent = filterTexts[filter] || 'Show: All Frames';

            // Update active state in dropdown
            document.querySelectorAll('.filter-dropdown-item[data-filter]').forEach(item => {
                item.classList.toggle('active', item.dataset.filter === filter);
            });

            // Update button styling
            btn.classList.toggle('has-filter', filter !== 'all');

            // Update reset button visibility
            updateResetButtonVisibility();

            // Apply filter
            applyFilter();

            // Save preference to localStorage (with generation ID prefix to avoid stale data)
            try {
                localStorage.setItem(`fds_filter_${GENERATION_ID}`, filter);
            } catch (e) { /* ignore localStorage errors */ }
        }

        /**
         * Set sort and update UI
         */
        function setSort(sort) {
            currentSort = sort;

            // Update active state in dropdown
            document.querySelectorAll('.filter-dropdown-item[data-sort]').forEach(item => {
                item.classList.toggle('active', item.dataset.sort === sort);
            });

            // Update reset button visibility
            updateResetButtonVisibility();

            // Apply sort then filter
            applySort();
            applyFilter();

            // Save preference
            try {
                localStorage.setItem(`fds_sort_${GENERATION_ID}`, sort);
            } catch (e) { /* ignore localStorage errors */ }
        }

        /**
         * Show/hide reset button based on current state
         */
        function updateResetButtonVisibility() {
            const resetBtn = document.getElementById('filterResetBtn');
            if (resetBtn) {
                const isDefault = currentFilter === 'all' && currentSort === 'timeline';
                resetBtn.classList.toggle('hidden', isDefault);
            }
        }

        /**
         * Reset filter and sort to defaults
         */
        function resetFilterSort() {
            setFilter('all');
            setSort('timeline');
            closeFilterDropdown();
        }

        /**
         * Toggle filter dropdown open/closed
         */
        function toggleFilterDropdown() {
            const menu = document.getElementById('filterDropdownMenu');
            const btn = document.getElementById('filterDropdownBtn');
            menu.classList.toggle('open');
            // Also toggle on the button's parent for styling
            if (btn) btn.closest('.filter-dropdown')?.classList.toggle('open');
        }

        /**
         * Close filter dropdown
         */
        function closeFilterDropdown() {
            const menu = document.getElementById('filterDropdownMenu');
            const btn = document.getElementById('filterDropdownBtn');
            if (menu) menu.classList.remove('open');
            if (btn) btn.closest('.filter-dropdown')?.classList.remove('open');
        }

        /**
         * Initialize filter/sort system
         */
        function initFilterSort() {
            // Load saved preferences (scoped to this generation)
            let savedFilter = 'all';
            let savedSort = 'timeline';
            try {
                savedFilter = localStorage.getItem(`fds_filter_${GENERATION_ID}`) || 'all';
                savedSort = localStorage.getItem(`fds_sort_${GENERATION_ID}`) || 'timeline';
            } catch (e) { /* ignore localStorage errors */ }

            // Setup desktop dropdown toggle
            const dropdownBtn = document.getElementById('filterDropdownBtn');
            if (dropdownBtn) {
                dropdownBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleFilterDropdown();
                });
            }

            // Setup mobile hamburger - toggles same dropdown
            const mobileMenuBtn = document.getElementById('mobileMenuBtn');
            if (mobileMenuBtn) {
                mobileMenuBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleFilterDropdown();
                });
            }

            // Setup filter items
            document.querySelectorAll('.filter-dropdown-item[data-filter]').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    setFilter(item.dataset.filter);
                    closeFilterDropdown();
                });
            });

            // Setup sort items
            document.querySelectorAll('.filter-dropdown-item[data-sort]').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    setSort(item.dataset.sort);
                    closeFilterDropdown();
                });
            });

            // Setup reset button
            const resetBtn = document.getElementById('filterResetBtn');
            if (resetBtn) {
                resetBtn.addEventListener('click', resetFilterSort);
            }

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.filter-dropdown') && !e.target.closest('.mobile-menu-btn')) {
                    closeFilterDropdown();
                }
            });

            // Apply saved preferences (after grid has rendered)
            setTimeout(() => {
                currentFilter = savedFilter;
                currentSort = savedSort;

                // Update UI to match saved state
                setFilter(savedFilter);
                setSort(savedSort);

                console.log('[FilterSort] Initialized with filter:', savedFilter, 'sort:', savedSort);
            }, 100);
        }

        // ====================================================================
        // GRID RENDERING
        // ====================================================================

        function renderGrid(frameIds) {
            const grid = document.getElementById('contactSheetGrid');
            grid.innerHTML = ''; // Clear loading message

            frameIds.forEach(frameId => {
                const frameData = FRAME_DATA[frameId];
                const card = createThumbnailCard(frameId, frameData);
                grid.appendChild(card);
            });
        }

        function createThumbnailCard(frameId, frameData) {
            const card = document.createElement('div');
            card.className = 'thumbnail-card';
            card.dataset.frameId = frameId;

            // Favorite badge (only show if favorited)
            const favoriteHTML = frameData.favorite
                ? '<div class="favorite-badge">★</div>'
                : '';

            // TC/Shot info (only show if enabled)
            const tcInfoHTML = SHOW_TC_INFO
                ? `<div class="thumbnail-info">
                    <div class="thumbnail-tc">TC: ${frameData.timecode}</div>
                    <div class="thumbnail-shot">${frameData.shot}</div>
                </div>`
                : '';

            card.innerHTML = `
                <div class="thumbnail-image-container">
                    <img class="thumbnail-image"
                         src="${frameData.thumbnail_url}"
                         alt="Frame ${frameId}"
                         loading="lazy"
                         onload="this.style.opacity='1'">
                    ${favoriteHTML}
                </div>
                ${tcInfoHTML}
            `;

            // Click handler - open modal
            card.addEventListener('click', () => openModal(frameId));

            return card;
        }

        // ====================================================================
        // GRID SIZE CONTROL
        // ====================================================================

        function setupEventListeners() {
            // Grid size buttons
            document.querySelectorAll('.grid-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const gridSize = e.target.dataset.grid;
                    setGridSize(gridSize);
                });
            });

            // Thumbnail size buttons
            document.querySelectorAll('.thumb-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const thumbSize = e.target.dataset.size;
                    setThumbnailSize(thumbSize);
                });
            });

            // Modal close button
            document.getElementById('modalClose').addEventListener('click', closeModal);

            // Prevent iOS horizontal swipe drift on home grid (but allow in modal)
            (function(){
                let sx=0, sy=0, tracking=false;
                document.addEventListener('touchstart', (e)=>{
                    if (e.touches && e.touches.length === 1) {
                        tracking = true;
                        sx = e.touches[0].clientX;
                        sy = e.touches[0].clientY;
                    } else {
                        tracking = false;
                    }
                }, {passive:true});

                document.addEventListener('touchmove', (e)=>{
                    if (!tracking) return;

                    // ONLY prevent on home grid, not when modal is open
                    const modalActive = document.getElementById('modalOverlay')?.classList.contains('active');
                    if (modalActive) return; // Allow all gestures in modal

                    const t = e.touches[0];
                    const dx = t.clientX - sx;
                    const dy = t.clientY - sy;

                    // Block ANY horizontal movement > 4px to prevent drift
                    if (Math.abs(dx) > 4) {
                        e.preventDefault();
                    }
                }, {passive:false});
            })();

            // Navigation arrows
            document.getElementById('navPrev').addEventListener('click', navigateToPrevFrame);
            document.getElementById('navNext').addEventListener('click', navigateToNextFrame);

            // Swipe gesture navigation for modal (iOS and Android)
            setupSwipeNavigation();

            // Favorite button
            document.getElementById('modalFavoriteBtn').addEventListener('click', toggleFavorite);

            // View mode radio buttons
            document.querySelectorAll('input[name="viewMode"]').forEach(radio => {
                radio.addEventListener('change', handleViewModeChange);
            });

            // Client feedback auto-save
            const feedbackTextarea = document.getElementById('clientFeedback');
            feedbackTextarea.addEventListener('input', debounce(() => {
                saveClientFeedback();
            }, 1000));

            // Colorist notes auto-save (when Firebase is enabled, both fields are editable)
            const coloristTextarea = document.getElementById('coloristNotes');
            coloristTextarea.addEventListener('input', debounce(() => {
                saveClientFeedback();
            }, 1000));

            // Ensure spacebar works in textareas (prevent any modal keyboard shortcuts from interfering)
            const textareas = document.querySelectorAll('textarea');
            textareas.forEach(textarea => {
                textarea.addEventListener('keydown', (e) => {
                    // Allow all normal text input, prevent event bubbling for space
                    if (e.key === ' ') {
                        e.stopPropagation(); // Stop spacebar from triggering favorite toggle
                    }
                });
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                const modal = document.getElementById('modalOverlay');
                const isModalOpen = modal.classList.contains('active');

                if (!isModalOpen) return;

                // Don't trigger shortcuts if user is typing in a textarea or input
                const isTyping = e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT';

                switch(e.key) {
                    case 'Escape':
                        closeModal();
                        e.preventDefault();
                        break;
                    case 'ArrowLeft':
                        if (!isTyping) {
                            navigateToPrevFrame();
                            e.preventDefault();
                        }
                        break;
                    case 'ArrowRight':
                        if (!isTyping) {
                            navigateToNextFrame();
                            e.preventDefault();
                        }
                        break;
                    case ' ':
                        if (!isTyping) {
                            toggleFavorite();
                            e.preventDefault();
                        }
                        break;
                }
            });

            // Close modal on overlay click
            document.getElementById('modalOverlay').addEventListener('click', (e) => {
                if (e.target.id === 'modalOverlay') {
                    closeModal();
                }
            });
        }

        function setGridSize(size) {
            currentGridSize = size;
            const grid = document.getElementById('contactSheetGrid');

            // Remove all grid size classes
            grid.classList.remove('grid-2x2', 'grid-3x3', 'grid-4x4', 'grid-5x5');

            // Add new grid size class
            grid.classList.add(`grid-${size}`);

            // Update button states
            document.querySelectorAll('.grid-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.grid === size);
            });
        }

        function setThumbnailSize(size) {
            const gridContainer = document.querySelector('.grid-container');

            // Remove all thumbnail size classes
            gridContainer.classList.remove('thumb-small', 'thumb-medium', 'thumb-large', 'thumb-max', 'thumb-huge');

            // Add new thumbnail size class
            if (size !== 'default') {
                gridContainer.classList.add(`thumb-${size}`);
            }

            // Update button states
            document.querySelectorAll('.thumb-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.size === size);
            });
        }

        // ====================================================================
        // MODAL FUNCTIONS
        // ====================================================================

        let modalFrameIndex = 0;
        let frameIdsList = [];

        /**
         * Get list of currently visible frame IDs (respecting filter)
         * Returns frames in current DOM order (respecting sort)
         */
        function getVisibleFrameIds() {
            const visibleCards = document.querySelectorAll('.thumbnail-card:not([style*="display: none"])');
            return Array.from(visibleCards).map(card => card.dataset.frameId);
        }

        function openModal(frameId) {
            console.log('[openModal] Opening modal for frame:', frameId);

            selectedFrameId = frameId;
            // Use visible frames only (respects current filter and sort)
            frameIdsList = getVisibleFrameIds();
            modalFrameIndex = frameIdsList.indexOf(frameId);

            const modal = document.getElementById('modalOverlay');
            modal.classList.add('loading'); // Hide content until image loads
            modal.classList.add('active');

            // Prevent background scrolling when modal is open
            document.body.classList.add('modal-open');

            // Mark frame as reviewed (client has viewed it)
            markFrameAsReviewed(frameId);

            // Delay to ensure CSS layout is fully applied before calculating image dimensions
            // Safari/Android needs more time for viewport calculations, especially in landscape
            setTimeout(() => {
                loadModalFrame(frameId);
                updateNavigationButtons();

                // For mobile landscape, do multiple recalculations as Safari/Android settles
                const isLandscape = window.innerWidth > window.innerHeight;
                const isMobileDevice = /iPhone|iPad|iPod|Android|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const isMobileLandscape = isLandscape && isMobileDevice && window.innerHeight < 500;

                if (isMobileLandscape) {
                    // Multiple recalculations for mobile landscape as browser UI settles
                    setTimeout(() => loadModalFrame(frameId), 100);
                    setTimeout(() => loadModalFrame(frameId), 200);
                    setTimeout(() => loadModalFrame(frameId), 400);
                    setTimeout(() => loadModalFrame(frameId), 700);
                }
            }, 50);

            log(`Opening modal for frame ${frameId} (${modalFrameIndex + 1}/${frameIdsList.length})`);
        }

        function closeModal() {
            const modal = document.getElementById('modalOverlay');
            modal.classList.remove('active');
            modal.classList.remove('fullscreen-mode');
            selectedFrameId = null;

            // Re-enable background scrolling
            document.body.classList.remove('modal-open');

            // Exit fullscreen if active
            if (document.fullscreenElement || document.webkitFullscreenElement ||
                document.mozFullScreenElement || document.msFullscreenElement) {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        function loadModalFrame(frameId) {
            console.log('[loadModalFrame] Loading frame:', frameId);
            const frameData = FRAME_DATA[frameId];
            console.log('[loadModalFrame] frameData:', frameData);
            console.log('[loadModalFrame] frameData.pill_positions:', frameData ? frameData.pill_positions : 'NO FRAME DATA');

            if (!frameData) {
                console.error('[loadModalFrame] No frameData for', frameId);
                return;
            }

            const modalImage = document.getElementById('modalImage');

            // Lock modal image dimensions to graded image size for consistent display
            // This prevents size jumping when switching between graded (1920px) and LUT preview (960px)
            const gradedImg = new Image();
            gradedImg.onload = () => {
                // Calculate the display dimensions based on screen size and orientation
                // Use window.innerHeight which matches our --vh CSS variable
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const isLandscape = viewportWidth > viewportHeight;
                const isMobileDevice = /iPhone|iPad|iPod|Android|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                // Mobile landscape: must be mobile device + landscape + small height
                const isMobileLandscape = isLandscape && isMobileDevice && viewportHeight < 500;
                const isMobilePortrait = !isLandscape && viewportWidth < 768;
                const isMobile = isMobileLandscape || isMobilePortrait;

                let maxWidth, maxHeight;

                if (isMobilePortrait) {
                    // Portrait mobile: image takes ~95% width, ~40% height
                    maxWidth = viewportWidth - 40;
                    maxHeight = viewportHeight * 0.4 - 60;
                } else if (isMobileLandscape) {
                    // Landscape mobile: FULLSCREEN image viewer (no panel)
                    maxWidth = viewportWidth - 40;
                    maxHeight = viewportHeight - 80;
                } else {
                    // Desktop or tablet
                    maxWidth = viewportWidth * 0.95 - 500;
                    maxHeight = viewportHeight * 0.95 - 120;
                }

                let displayWidth = gradedImg.naturalWidth;
                let displayHeight = gradedImg.naturalHeight;

                // Scale down to fit constraints while maintaining aspect ratio
                const widthRatio = maxWidth / displayWidth;
                const heightRatio = maxHeight / displayHeight;
                const scale = Math.min(widthRatio, heightRatio, 1); // Don't scale up

                displayWidth = Math.round(displayWidth * scale);
                displayHeight = Math.round(displayHeight * scale);

                // Lock the dimensions
                modalImage.style.width = displayWidth + 'px';
                modalImage.style.height = displayHeight + 'px';
                modalImage.style.objectFit = 'contain';

                console.log(`[loadModalFrame] Locked dimensions to ${displayWidth}x${displayHeight} (mobileLandscape: ${isMobileLandscape}, mobilePortrait: ${isMobilePortrait}, isMobileDevice: ${isMobileDevice})`);

                // Remove loading state - content is ready to show
                document.getElementById('modalOverlay').classList.remove('loading');

                // Update metadata overlay AFTER dimensions are set
                updateMetadataOverlay(frameData);

                // Now apply the view mode (image will scale to fit locked dimensions)
                const { mode: modeToApply, isFallback } = getAvailableViewMode(frameId, lastViewedMode);
                console.log(`[loadModalFrame] lastViewedMode: ${lastViewedMode}, applying: ${modeToApply}, isFallback: ${isFallback}`);
                updateVersionOptions(frameData, modeToApply);
                applyViewMode(modeToApply, frameData, isFallback);
            };

            gradedImg.onerror = () => {
                console.warn('[loadModalFrame] Failed to load graded image for dimension calculation, proceeding without lock');
                // Clear any previous dimension lock
                modalImage.style.width = '';
                modalImage.style.height = '';

                // Remove loading state even on error
                document.getElementById('modalOverlay').classList.remove('loading');

                // Still update metadata overlay (will use default sizing)
                updateMetadataOverlay(frameData);

                const { mode: modeToApply, isFallback } = getAvailableViewMode(frameId, lastViewedMode);
                updateVersionOptions(frameData, modeToApply);
                applyViewMode(modeToApply, frameData, isFallback);
            };

            gradedImg.src = frameData.graded_url;

            // Update frame info
            document.getElementById('modalTimecode').textContent = `TC: ${frameData.timecode}`;
            document.getElementById('modalShot').textContent = `Shot: ${frameData.shot}`;

            // Show/hide TC/Shot info based on Contact Sheets setting
            const tcElement = document.getElementById('modalTimecode');
            const shotElement = document.getElementById('modalShot');
            if (SHOW_TC_INFO) {
                tcElement.style.display = 'block';
                shotElement.style.display = 'block';
            } else {
                tcElement.style.display = 'none';
                shotElement.style.display = 'none';
            }

            // Update frame counter
            const currentPos = modalFrameIndex + 1;
            const total = frameIdsList.length;
            document.getElementById('modalFrameCounter').textContent = `${currentPos} / ${total}`;

            // Update favorite button
            const favBtn = document.getElementById('modalFavoriteBtn');
            favBtn.classList.toggle('active', frameData.favorite);

            // Initialize LUT options for this frame (shows/hides based on frame config)
            initializeLUTOptions(frameData);

            // Update notes - load from localStorage first, fallback to FRAME_DATA
            const savedColoristNotes = localStorage.getItem(`colorist_notes_${frameId}`);
            document.getElementById('coloristNotes').value = savedColoristNotes || frameData.notes.colorist || '';

            // Load client feedback from localStorage
            const savedFeedback = localStorage.getItem(`feedback_${frameId}`);
            document.getElementById('clientFeedback').value = savedFeedback || frameData.notes.client || '';
        }

        function updateMetadataOverlay(frameData) {
            const overlay = document.getElementById('modalImageOverlay');
            const modalImage = document.getElementById('modalImage');
            overlay.innerHTML = '';

            if (!frameData.pill_positions) {
                return;
            }

            // Calculate scale factor based on displayed image size vs reference size
            // Reference: desktop displays image at roughly 1000px width
            const referenceWidth = 1000;
            const displayedWidth = modalImage.offsetWidth || modalImage.clientWidth || referenceWidth;
            const scaleFactor = Math.min(1, displayedWidth / referenceWidth);

            // Base sizes (desktop)
            const baseFontSize = 13;
            const basePadding = 6;
            const baseMargin = 16;
            const basePillHeight = 31;
            const basePillGap = 8;

            // Scaled sizes
            const fontSize = Math.max(8, Math.round(baseFontSize * scaleFactor));
            const padding = Math.max(3, Math.round(basePadding * scaleFactor));
            const margin = Math.max(8, Math.round(baseMargin * scaleFactor));
            const pillHeight = Math.max(18, Math.round(basePillHeight * scaleFactor));
            const pillGap = Math.max(4, Math.round(basePillGap * scaleFactor));

            // Group pills by corner to handle stacking
            const pillsByCorner = {
                'top-left': [],
                'top-right': [],
                'bottom-left': [],
                'bottom-right': []
            };

            for (const [text, position] of Object.entries(frameData.pill_positions)) {
                pillsByCorner[position].push(text);
            }

            // Create pills with vertical stacking
            for (const [corner, texts] of Object.entries(pillsByCorner)) {
                texts.forEach((text, index) => {
                    const pill = document.createElement('div');
                    pill.className = `metadata-pill pill-${corner}`;
                    pill.textContent = text;

                    // Apply scaled styles directly
                    pill.style.fontSize = `${fontSize}px`;
                    pill.style.padding = `${padding}px ${padding * 2}px`;

                    // Add vertical offset for stacked pills in the same corner
                    const offset = index * (pillHeight + pillGap);
                    if (corner.includes('top')) {
                        pill.style.top = `${margin + offset}px`;
                    } else {
                        pill.style.bottom = `${margin + offset}px`;
                    }

                    overlay.appendChild(pill);
                });
            }
        }

        function updateVersionOptions(frameData, viewMode = 'graded') {
            const dropdownContainer = document.getElementById('versionDropdownContainer');
            const dropdownSelected = document.getElementById('dropdownSelected');
            const dropdownOptions = document.getElementById('dropdownOptions');

            // Clear previous options
            dropdownOptions.innerHTML = '';

            if (!frameData.versions || frameData.versions.length === 0) {
                dropdownContainer.style.display = 'none';
                return;
            }

            // Hide dropdown if only one version (no choice to make)
            if (frameData.versions.length === 1) {
                dropdownContainer.style.display = 'none';

                // Still update the image if in graded mode (supports both old and new values)
                if ((viewMode === 'graded' || viewMode === 'current_grade') && frameData.versions[0]) {
                    const modalImage = document.getElementById('modalImage');
                    modalImage.src = frameData.versions[0].image_url;
                }
                return;
            }

            // Store versions globally for dropdown access
            window.currentFrameVersions = frameData.versions;

            // Separate grade versions from LUT options (if we add that distinction later)
            const gradeVersions = frameData.versions; // All are grade versions for now

            // Sort: Active version first (with star), then others
            const sortedVersions = [...gradeVersions].sort((a, b) => {
                if (a.is_active && !b.is_active) return -1;
                if (!a.is_active && b.is_active) return 1;
                return 0;
            });

            // Populate dropdown with grade versions
            sortedVersions.forEach((version) => {
                const originalIndex = gradeVersions.indexOf(version);
                const optionDiv = document.createElement('div');
                optionDiv.className = 'fds-dropdown-option';
                optionDiv.dataset.value = `version_${originalIndex}`;
                optionDiv.dataset.index = originalIndex;
                // Star on LEFT side for better visibility
                const displayText = version.is_active
                    ? `⭐ ${version.display_name}`
                    : version.display_name;
                optionDiv.textContent = displayText;

                // Tooltip: starred items explain the star, others show full name
                if (version.is_active) {
                    optionDiv.title = "⭐ = Colorist's preferred grade";
                    optionDiv.classList.add('tooltip-enabled');
                    optionDiv.setAttribute('data-tooltip', "⭐ = Colorist's preferred grade");
                } else {
                    optionDiv.title = version.display_name;
                }

                // Click handler for option
                optionDiv.addEventListener('click', function() {
                    selectDropdownOption(this);
                });

                dropdownOptions.appendChild(optionDiv);
            });

            // Show dropdown container
            dropdownContainer.style.display = 'block';

            // Determine which version to select:
            // 1. Check if we have a saved selection for this frame
            // 2. Otherwise, find is_active version
            // 3. Otherwise, default to index 0 (original grade)
            let selectedIndex = 0; // Default to first version (original grade)

            // Check for saved selection
            if (frameDropdownSelections[selectedFrameId] !== undefined) {
                selectedIndex = frameDropdownSelections[selectedFrameId];
                console.log(`[updateVersionOptions] Restoring saved selection for frame ${selectedFrameId}: version_${selectedIndex}`);
            } else {
                // Look for is_active version
                const activeIndex = gradeVersions.findIndex(v => v.is_active);
                if (activeIndex >= 0) {
                    selectedIndex = activeIndex;
                    console.log(`[updateVersionOptions] Found is_active version at index ${selectedIndex}`);
                } else {
                    console.log(`[updateVersionOptions] No is_active found, defaulting to index 0`);
                }
                // Save this as the initial selection
                frameDropdownSelections[selectedFrameId] = selectedIndex;
            }

            // Set dropdown to selected version
            const selectedVersion = gradeVersions[selectedIndex];
            if (selectedVersion) {
                // Ensure dropdown is in closed state
                dropdownSelected.classList.remove('open');
                dropdownOptions.style.display = 'none';

                // Check if THIS specific version is marked as active (for star display)
                const hasActiveStar = selectedVersion.is_active === true;
                // Star on LEFT side for better visibility
                dropdownSelected.textContent = hasActiveStar
                    ? `⭐ ${selectedVersion.display_name}`
                    : selectedVersion.display_name;
                dropdownSelected.dataset.value = `version_${selectedIndex}`;
                // Tooltip: starred items explain the star, others show full name
                dropdownSelected.title = hasActiveStar
                    ? "⭐ = Colorist's preferred grade"
                    : selectedVersion.display_name;

                // Add tooltip to dropdown field if it shows a starred version
                if (hasActiveStar) {
                    dropdownSelected.classList.add('tooltip-enabled');
                    dropdownSelected.setAttribute('data-tooltip', "\u2B50 = Colorist's preferred grade");
                } else {
                    dropdownSelected.classList.remove('tooltip-enabled');
                    dropdownSelected.removeAttribute('data-tooltip');
                }

                console.log(`[updateVersionOptions] Set dropdown to index ${selectedIndex}: "${selectedVersion.display_name}", is_active: ${selectedVersion.is_active}`);

                // CRITICAL: Update modal image to match restored selection
                // This ensures the image shows the saved version, not just the dropdown label
                // Only update if viewMode is 'graded' or 'current_grade' (not 'ungraded'/'no_grade')
                const modalImage = document.getElementById('modalImage');
                if (viewMode === 'graded' || viewMode === 'current_grade') {
                    // Update image to match the selected version
                    modalImage.src = selectedVersion.image_url;
                    console.log(`[updateVersionOptions] Updated modal image to match restored selection: ${selectedVersion.display_name}`);
                }

                // Mark as selected in options
                const optionElements = dropdownOptions.querySelectorAll('.fds-dropdown-option');
                optionElements.forEach(opt => {
                    if (opt.dataset.index == selectedIndex) {
                        opt.classList.add('selected');
                    }
                });
            }

            // Setup click handler ONLY if not already attached
            if (!dropdownSelected.hasAttribute('data-listener-attached')) {
                dropdownSelected.addEventListener('click', toggleDropdown);
                dropdownSelected.setAttribute('data-listener-attached', 'true');
            }

            console.log('[updateVersionOptions] Populated custom dropdown with', sortedVersions.length, 'versions');
        }

        function toggleDropdown() {
            const dropdownSelected = document.getElementById('dropdownSelected');
            const dropdownOptions = document.getElementById('dropdownOptions');
            const isOpen = dropdownOptions.style.display === 'block';

            if (isOpen) {
                dropdownOptions.style.display = 'none';
                dropdownSelected.classList.remove('open');
            } else {
                dropdownOptions.style.display = 'block';
                dropdownSelected.classList.add('open');
            }
        }

        function selectDropdownOption(optionElement) {
            const dropdownSelected = document.getElementById('dropdownSelected');
            const dropdownOptions = document.getElementById('dropdownOptions');

            // Get the selected version data
            const selectedIndex = parseInt(optionElement.dataset.index);
            const selectedVersion = window.currentFrameVersions ? window.currentFrameVersions[selectedIndex] : null;

            // Save this selection for the current frame
            if (selectedFrameId) {
                frameDropdownSelections[selectedFrameId] = selectedIndex;
                console.log(`[selectDropdownOption] Saved selection for frame ${selectedFrameId}: index ${selectedIndex}`);
            }

            if (selectedVersion) {
                // Check if THIS version has is_active flag for star display
                const hasActiveStar = selectedVersion.is_active === true;
                // Star on LEFT side for better visibility
                dropdownSelected.textContent = hasActiveStar
                    ? `⭐ ${selectedVersion.display_name}`
                    : selectedVersion.display_name;
                // Tooltip: starred items explain the star, others show full name
                dropdownSelected.title = hasActiveStar
                    ? "⭐ = Colorist's preferred grade"
                    : selectedVersion.display_name;
                // Add/remove tooltip based on whether selected version has star
                if (hasActiveStar) {
                    dropdownSelected.classList.add('tooltip-enabled');
                    dropdownSelected.setAttribute('data-tooltip', "⭐ = Colorist's preferred grade");
                } else {
                    dropdownSelected.classList.remove('tooltip-enabled');
                    dropdownSelected.removeAttribute('data-tooltip');
                }

                console.log(`[selectDropdownOption] Selected "${selectedVersion.display_name}", is_active: ${selectedVersion.is_active}, showing star: ${hasActiveStar}`);
            } else {
                // Fallback to option text
                dropdownSelected.textContent = optionElement.textContent;
                dropdownSelected.classList.remove('tooltip-enabled');
                dropdownSelected.removeAttribute('data-tooltip');
            }

            dropdownSelected.dataset.value = optionElement.dataset.value;

            // Update selected class
            dropdownOptions.querySelectorAll('.fds-dropdown-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            optionElement.classList.add('selected');

            // Close dropdown
            dropdownOptions.style.display = 'none';
            dropdownSelected.classList.remove('open');

            // Update image if Current Grade radio is selected
            const currentGradeRadio = document.getElementById('viewGraded');
            if (currentGradeRadio && currentGradeRadio.checked && selectedVersion) {
                const modalImage = document.getElementById('modalImage');
                modalImage.src = selectedVersion.image_url;
                console.log(`[selectDropdownOption] Updated image to: ${selectedVersion.display_name}`);
            }
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            const customDropdown = document.getElementById('customDropdown');
            const dropdownOptions = document.getElementById('dropdownOptions');
            const dropdownSelected = document.getElementById('dropdownSelected');

            if (customDropdown && !customDropdown.contains(e.target)) {
                dropdownOptions.style.display = 'none';
                dropdownSelected.classList.remove('open');
            }
        });

        function updateNavigationButtons() {
            const prevBtn = document.getElementById('navPrev');
            const nextBtn = document.getElementById('navNext');

            prevBtn.disabled = modalFrameIndex <= 0;
            nextBtn.disabled = modalFrameIndex >= frameIdsList.length - 1;
        }

        function navigateToPrevFrame() {
            if (modalFrameIndex > 0) {
                modalFrameIndex--;
                const frameId = frameIdsList[modalFrameIndex];
                selectedFrameId = frameId;
                markFrameAsReviewed(frameId);  // Mark as reviewed when navigating
                loadModalFrame(frameId);
                updateNavigationButtons();
            }
        }

        function navigateToNextFrame() {
            if (modalFrameIndex < frameIdsList.length - 1) {
                modalFrameIndex++;
                const frameId = frameIdsList[modalFrameIndex];
                selectedFrameId = frameId;
                markFrameAsReviewed(frameId);  // Mark as reviewed when navigating
                loadModalFrame(frameId);
                updateNavigationButtons();
            }
        }

        function toggleFavorite() {
            if (!selectedFrameId) return;

            const frameData = FRAME_DATA[selectedFrameId];
            frameData.favorite = !frameData.favorite;

            // Update modal button
            const favBtn = document.getElementById('modalFavoriteBtn');
            favBtn.classList.toggle('active', frameData.favorite);

            // Update grid card
            const card = document.querySelector(`[data-frame-id="${selectedFrameId}"]`);
            if (card) {
                // Toggle favorited class for orange border
                card.classList.toggle('favorited', frameData.favorite);

                const badge = card.querySelector('.favorite-badge');
                if (frameData.favorite && !badge) {
                    // Add badge with yellow filled star
                    const container = card.querySelector('.thumbnail-image-container');
                    const newBadge = document.createElement('div');
                    newBadge.className = 'favorite-badge';
                    newBadge.textContent = '★'; // Filled yellow star
                    container.appendChild(newBadge);
                } else if (!frameData.favorite && badge) {
                    // Remove badge
                    badge.remove();
                }
            }

            // Save to Firebase if connected, otherwise localStorage
            if (favoritesRef) {
                favoritesRef.child(selectedFrameId).set(frameData.favorite ? true : false)
                    .then(() => {
                        log(`Favorite saved to Firebase for frame ${selectedFrameId}`);
                    })
                    .catch((error) => {
                        console.error('[ContactSheet] Firebase favorite save error:', error);
                        // Fallback to localStorage
                        saveFavoritesToStorage();
                    });
            } else {
                saveFavoritesToStorage();
            }

            log(`Frame ${selectedFrameId} ${frameData.favorite ? 'favorited' : 'unfavorited'}`);
        }

        // Mark a frame as reviewed (client has opened it in modal)
        function markFrameAsReviewed(frameId) {
            // Skip if review borders are disabled
            if (!ENABLE_REVIEW_BORDERS) return;

            if (!frameId || !FRAME_DATA[frameId]) return;

            // Skip if already reviewed
            if (FRAME_DATA[frameId].reviewed) return;

            FRAME_DATA[frameId].reviewed = true;

            // Update grid card border
            const card = document.querySelector(`[data-frame-id="${frameId}"]`);
            if (card) {
                card.classList.add('reviewed');
            }

            // Update frame counter
            updateFrameCounter();

            // Save to Firebase if connected, otherwise localStorage
            if (reviewedRef) {
                reviewedRef.child(frameId).set(true)
                    .then(() => {
                        log(`Reviewed state saved to Firebase for frame ${frameId}`);
                    })
                    .catch((error) => {
                        console.error('[ContactSheet] Firebase reviewed save error:', error);
                        // Fallback to localStorage
                        saveReviewedToStorage();
                    });
            } else {
                saveReviewedToStorage();
            }

            log(`Frame ${frameId} marked as reviewed`);
        }

        function saveReviewedToStorage() {
            const reviewed = {};
            for (const [frameId, data] of Object.entries(FRAME_DATA)) {
                if (data.reviewed) {
                    reviewed[frameId] = true;
                }
            }
            localStorage.setItem('reviewed', JSON.stringify(reviewed));
        }

        function loadReviewedFromStorage() {
            // Skip if review borders are disabled
            if (!ENABLE_REVIEW_BORDERS) return;

            const saved = localStorage.getItem('reviewed');
            if (saved) {
                const reviewed = JSON.parse(saved);
                for (const frameId in reviewed) {
                    if (FRAME_DATA[frameId]) {
                        FRAME_DATA[frameId].reviewed = true;
                        // Update grid card border
                        const card = document.querySelector(`[data-frame-id="${frameId}"]`);
                        if (card) {
                            card.classList.add('reviewed');
                        }
                    }
                }
                // Update frame counter after loading reviewed states
                updateFrameCounter();
            }
        }

        function saveFavoritesToStorage() {
            const favorites = {};
            for (const [frameId, data] of Object.entries(FRAME_DATA)) {
                if (data.favorite) {
                    favorites[frameId] = true;
                }
            }
            localStorage.setItem('favorites', JSON.stringify(favorites));
        }

        function loadFavoritesFromStorage() {
            const saved = localStorage.getItem('favorites');
            if (saved) {
                const favorites = JSON.parse(saved);
                for (const frameId in favorites) {
                    if (FRAME_DATA[frameId]) {
                        FRAME_DATA[frameId].favorite = true;
                    }
                }
            }
        }

        // ====================================================================
        // VIEW MODE SWITCHING
        // ====================================================================

        function handleViewModeChange(e) {
            if (!selectedFrameId) return;

            const mode = e.target.value;
            const frameData = FRAME_DATA[selectedFrameId];

            console.log('[ViewMode] Change detected:', mode);

            // Delegate to applyLUT which handles all view modes and saves lastViewedMode
            applyLUT(mode, frameData);
        }

        // ====================================================================
        // CLIENT FEEDBACK MANAGEMENT
        // ====================================================================

        function saveClientFeedback() {
            if (!selectedFrameId) return;

            const feedback = document.getElementById('clientFeedback').value;
            const coloristNotes = document.getElementById('coloristNotes').value;

            // Update FRAME_DATA
            FRAME_DATA[selectedFrameId].notes.client = feedback;
            FRAME_DATA[selectedFrameId].notes.colorist = coloristNotes;

            // Save to Firebase if connected, otherwise localStorage
            if (notesRef) {
                notesRef.child(selectedFrameId).set({
                    client: feedback,
                    colorist: coloristNotes,
                    updated_at: Date.now()
                }).then(() => {
                    showSaveIndicator();
                    log(`Feedback saved to Firebase for frame ${selectedFrameId}`);
                }).catch((error) => {
                    console.error('[ContactSheet] Firebase save error:', error);
                    saveToLocalStorage(selectedFrameId, feedback, coloristNotes);
                });
            } else {
                saveToLocalStorage(selectedFrameId, feedback, coloristNotes);
            }
        }

        function saveToLocalStorage(frameId, feedback, coloristNotes) {
            try {
                localStorage.setItem(`feedback_${frameId}`, feedback);
                localStorage.setItem(`colorist_notes_${frameId}`, coloristNotes);
                localStorage.setItem('generation_id', GENERATION_ID);
            } catch (e) {
                console.warn('[ContactSheet] localStorage save failed:', e);
            }
            showSaveIndicator();
            log(`Feedback saved to localStorage for frame ${frameId}`);
        }

        function loadNotesFromStorage(frameId) {
            const savedFeedback = localStorage.getItem(`feedback_${frameId}`) || '';
            const savedColoristNotes = localStorage.getItem(`colorist_notes_${frameId}`) || '';
            return { client: savedFeedback, colorist: savedColoristNotes };
        }

        function showSaveIndicator() {
            const indicator = document.getElementById('autoSaveIndicator');
            indicator.textContent = '💾 Saved';
            indicator.classList.add('saved');
            setTimeout(() => {
                indicator.textContent = '';
                indicator.classList.remove('saved');
            }, 2000);
        }

        // ====================================================================
        // UTILITY FUNCTIONS
        // ====================================================================

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // ====================================================================
        // LUT SELECTION FUNCTIONS
        // ====================================================================

        /**
         * Get an available view mode for a frame, with smart fallback
         * If the requested mode isn't available (custom looks), falls back gracefully
         * Returns object: { mode: string, isFallback: boolean }
         */
        function getAvailableViewMode(frameId, requestedMode) {
            const frameConfig = getFrameLUTConfig(frameId);

            // Check if requested mode is available
            const modeAvailability = {
                'current_grade': frameConfig.include_current_grade,
                'graded': frameConfig.include_current_grade,  // Legacy alias
                'no_grade': frameConfig.include_no_grade,
                'ungraded': frameConfig.include_no_grade,  // Legacy alias
                'lut_1': frameConfig.lut_1_enabled,
                'lut_2': frameConfig.lut_2_enabled,
                'lut_3': frameConfig.lut_3_enabled,
                'lut_4': frameConfig.lut_4_enabled,
            };

            // Normalize legacy values
            if (requestedMode === 'graded') requestedMode = 'current_grade';
            if (requestedMode === 'ungraded') requestedMode = 'no_grade';

            // If requested mode is available, use it
            if (modeAvailability[requestedMode]) {
                return { mode: requestedMode, isFallback: false };
            }

            // Fallback order: current_grade -> no_grade -> lut_1 -> lut_2 -> lut_3 -> lut_4
            const fallbackOrder = ['current_grade', 'no_grade', 'lut_1', 'lut_2', 'lut_3', 'lut_4'];
            for (const mode of fallbackOrder) {
                if (modeAvailability[mode]) {
                    console.log(`[ViewMode] Requested '${requestedMode}' not available, falling back to '${mode}'`);
                    return { mode: mode, isFallback: true };
                }
            }

            // This shouldn't happen, but default to current_grade
            return { mode: 'current_grade', isFallback: true };
        }

        /**
         * Apply a view mode - select radio button and update image
         * @param {string} mode - The view mode to apply
         * @param {object} frameData - Frame data
         * @param {boolean} isFallback - If true, don't save as lastViewedMode
         */
        function applyViewMode(mode, frameData, isFallback = false) {
            // Map mode to radio button ID
            const radioIdMap = {
                'current_grade': 'viewGraded',
                'graded': 'viewGraded',
                'no_grade': 'viewUngraded',
                'ungraded': 'viewUngraded',
                'lut_1': 'viewLut1',
                'lut_2': 'viewLut2',
                'lut_3': 'viewLut3',
                'lut_4': 'viewLut4',
            };

            const radioId = radioIdMap[mode];
            if (radioId) {
                const radio = document.getElementById(radioId);
                if (radio) {
                    radio.checked = true;
                    // Apply the LUT/view change (pass isFallback to prevent saving)
                    applyLUT(mode, frameData, isFallback);
                }
            }
        }

        /**
         * Initialize LUT options based on configuration
         */
        function initializeLUTOptions(frameData) {
            console.log('[LUT] Initializing LUT options for frame:', selectedFrameId);

            // Get frame-specific config (merges global with custom overrides)
            const frameConfig = getFrameLUTConfig(selectedFrameId);
            console.log('[LUT] Frame config:', frameConfig);

            // Show/hide Current Grade based on config
            const currentGradeDiv = document.getElementById('currentGradeOption');
            if (frameConfig.include_current_grade) {
                currentGradeDiv.style.display = 'flex';
            } else {
                currentGradeDiv.style.display = 'none';
            }

            // Show/hide No Grade based on config
            const noGradeDiv = document.getElementById('noGradeOption');
            if (frameConfig.include_no_grade) {
                noGradeDiv.style.display = 'flex';
            } else {
                noGradeDiv.style.display = 'none';
            }

            // LUT 1-4 - show/hide and set labels with tooltips
            for (let i = 1; i <= 4; i++) {
                const lutDiv = document.getElementById(`lut${i}Option`);
                const lutLabel = document.getElementById(`lut${i}Label`);
                const lutEnabled = frameConfig[`lut_${i}_enabled`];
                // Use per-frame LUT name if available, otherwise fall back to global
                const lutName = frameConfig[`lut_${i}_default`] || LUT_CONFIG[`lut_${i}_default`];

                if (lutEnabled) {
                    lutDiv.style.display = 'flex';
                    // Set label with "LUT X" (inherits color) + white span for LUT name
                    if (lutName && lutName !== '(Select LUT)') {
                        lutLabel.innerHTML = `LUT ${i} <span class="lut-name">${lutName}</span>`;
                        // Set tooltip to show full name on hover
                        lutLabel.title = lutName;
                    } else {
                        lutLabel.textContent = `LUT ${i}`;
                        lutLabel.title = '';
                    }
                } else {
                    lutDiv.style.display = 'none';
                }
            }

            // Hide entire "Look Options" section if only Current Grade is shown
            // (no ungraded, no other versions, no LUTs = no choice to make)
            const recommendedLookSection = document.querySelector('.modal-section:has(.radio-group)');
            if (recommendedLookSection) {
                const visibleOptions = [];
                if (frameConfig.include_current_grade) visibleOptions.push('current_grade');
                if (frameConfig.include_no_grade) visibleOptions.push('no_grade');
                for (let i = 1; i <= 4; i++) {
                    if (frameConfig[`lut_${i}_enabled`]) visibleOptions.push(`lut_${i}`);
                }

                // Also check if there are multiple grade versions (dropdown would show)
                const hasMultipleVersions = frameData.versions && Object.keys(frameData.versions).length > 1;

                // Hide section if only Current Grade is available AND no version dropdown
                if (visibleOptions.length === 1 && visibleOptions[0] === 'current_grade' && !hasMultipleVersions) {
                    recommendedLookSection.style.display = 'none';
                    console.log('[LUT] Hiding Look Options section - only Current Grade available');
                } else {
                    recommendedLookSection.style.display = 'block';
                }
            }

            // If current selection is now hidden, switch to first visible option
            // But treat this as a fallback so we don't overwrite lastViewedMode
            const currentRadio = document.querySelector('input[name="viewMode"]:checked');
            if (currentRadio) {
                const currentOption = currentRadio.closest('.radio-option, .current-grade-row');
                if (currentOption && currentOption.style.display === 'none') {
                    // Find first visible option and select it
                    const firstVisible = document.querySelector('.radio-option:not([style*="display: none"]) input[type="radio"], .current-grade-row:not([style*="display: none"]) input[type="radio"]');
                    if (firstVisible) {
                        firstVisible.checked = true;
                        // Pass true for isFallback to preserve lastViewedMode
                        applyLUT(firstVisible.value, frameData, true);
                    }
                }
            }

            // Attach change handlers to all radio buttons (remove old listeners first)
            document.querySelectorAll('input[name="viewMode"]').forEach(radio => {
                // Clone and replace to remove old listeners
                const newRadio = radio.cloneNode(true);
                radio.parentNode.replaceChild(newRadio, radio);
                newRadio.addEventListener('change', function() {
                    if (this.checked) {
                        applyLUT(this.value, frameData);
                    }
                });
            });
        }

        /**
         * Apply LUT selection
         * @param {string} lutId - The LUT/view mode to apply
         * @param {object} frameData - Frame data (optional, will lookup if not provided)
         * @param {boolean} isFallback - If true, don't save as lastViewedMode (preserves user's original choice)
         */
        function applyLUT(lutId, frameData, isFallback = false) {
            const modalImage = document.getElementById('modalImage');

            if (!frameData) {
                frameData = FRAME_DATA[selectedFrameId];
            }

            if (!frameData) return;

            console.log('[LUT] Applying:', lutId, isFallback ? '(fallback - not saving)' : '(user selection - saving)');

            // Only save as last viewed mode if this is an explicit user selection, not a fallback
            if (!isFallback) {
                lastViewedMode = lutId;
            }

            if (lutId === 'current_grade') {
                // Check if version dropdown is active
                const versionDropdown = document.getElementById('versionDropdownContainer');
                if (versionDropdown && versionDropdown.style.display !== 'none') {
                    // Get selected version from FDS dropdown
                    const dropdownSelected = document.getElementById('dropdownSelected');
                    const selectedText = dropdownSelected.textContent.trim();

                    // Find matching version
                    const version = frameData.versions.find(v =>
                        (v.display_name + (v.is_active ? ' ⭐' : '')).trim() === selectedText
                    );

                    if (version) {
                        modalImage.src = version.image_url;
                    } else {
                        modalImage.src = frameData.graded_url;
                    }
                } else {
                    modalImage.src = frameData.graded_url;
                }
            } else if (lutId === 'no_grade') {
                // Use fullsize external file for high-quality viewing
                console.log('[LUT] Using fullsize ungraded for viewing:', frameData.ungraded_url);
                modalImage.src = frameData.ungraded_url;
            } else if (lutId.startsWith('lut_')) {
                // LUT transformation using browser-based LUT engine
                // Check for per-frame LUT file key first, then fall back to global slot
                const frameLutKey = `frame_${selectedFrameId}_${lutId}`;
                const effectiveLutKey = (lutManager && lutManager.isLoaded(frameLutKey)) ? frameLutKey : lutId;

                if (!lutManager || !lutManager.isLoaded(effectiveLutKey)) {
                    console.warn(`[LUT] ${lutId} not loaded (checked ${effectiveLutKey}), showing ungraded`);
                    modalImage.src = frameData.ungraded_url;
                    return;
                }

                // Check cache first (include effective key for per-frame LUTs)
                const cacheKey = `${selectedFrameId}_${effectiveLutKey}`;
                if (lutManager.cache[cacheKey]) {
                    modalImage.src = lutManager.cache[cacheKey];
                    return;
                }

                // Show loading state
                modalImage.style.opacity = '0.5';

                // Load ungraded image and apply LUT
                const ungradedImg = new Image();
                ungradedImg.crossOrigin = 'anonymous';

                ungradedImg.onload = () => {
                    try {
                        const result = lutManager.applyLUT(selectedFrameId, effectiveLutKey, ungradedImg);
                        if (result) {
                            modalImage.src = result;
                        } else {
                            modalImage.src = frameData.ungraded_url;
                        }
                    } catch (err) {
                        console.error('[LUT] Error applying LUT:', err);
                        modalImage.src = frameData.ungraded_url;
                    }
                    modalImage.style.opacity = '1';
                };

                ungradedImg.onerror = () => {
                    console.error('[LUT] Failed to load ungraded image');
                    modalImage.style.opacity = '1';
                };

                // Use embedded base64 image for LUT processing (CORS-safe)
                const lutSourceUrl = frameData.ungraded_lut_url || frameData.ungraded_url;
                console.log('[LUT] Using embedded ungraded for LUT processing:', lutSourceUrl.substring(0, 50) + '...');
                ungradedImg.src = lutSourceUrl;
            }
        }

        // ====================================================================
        // LUT ENGINE - Browser-based 3D LUT Application (Validated against colour-science)
        // ====================================================================

        class LUTEngine {
            constructor() {
                this.lut = null;
                this.size = 0;
                this.name = '';
                this.domainMin = [0, 0, 0];
                this.domainMax = [1, 1, 1];
                this.isLoaded = false;
            }

            parse(cubeText, name = null) {
                const lines = cubeText.split('\n');
                const data = [];

                this.name = name || 'Untitled';
                this.size = 0;
                this.domainMin = [0, 0, 0];
                this.domainMax = [1, 1, 1];

                for (const line of lines) {
                    const trimmed = line.trim();
                    if (!trimmed || trimmed.startsWith('#')) continue;

                    if (trimmed.startsWith('TITLE')) {
                        if (!name) this.name = trimmed.replace(/^TITLE\s*"?/, '').replace(/"?\s*$/, '');
                        continue;
                    }
                    if (trimmed.startsWith('LUT_3D_SIZE')) {
                        this.size = parseInt(trimmed.split(/\s+/)[1]);
                        continue;
                    }
                    if (trimmed.startsWith('DOMAIN_MIN')) {
                        const parts = trimmed.split(/\s+/);
                        this.domainMin = [parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3])];
                        continue;
                    }
                    if (trimmed.startsWith('DOMAIN_MAX')) {
                        const parts = trimmed.split(/\s+/);
                        this.domainMax = [parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3])];
                        continue;
                    }
                    if (trimmed.startsWith('LUT_1D') || trimmed.startsWith('LUT_3D_INPUT')) continue;

                    const parts = trimmed.split(/\s+/);
                    if (parts.length >= 3) {
                        const r = parseFloat(parts[0]), g = parseFloat(parts[1]), b = parseFloat(parts[2]);
                        if (!isNaN(r) && !isNaN(g) && !isNaN(b)) data.push([r, g, b]);
                    }
                }

                if (this.size === 0) {
                    const cubeRoot = Math.round(Math.pow(data.length, 1/3));
                    if (cubeRoot ** 3 === data.length) this.size = cubeRoot;
                    else throw new Error('Could not determine LUT size');
                }

                this.lut = new Float32Array(data.length * 3);
                for (let i = 0; i < data.length; i++) {
                    this.lut[i * 3] = data[i][0];
                    this.lut[i * 3 + 1] = data[i][1];
                    this.lut[i * 3 + 2] = data[i][2];
                }

                this.isLoaded = true;
                return { name: this.name, size: this.size };
            }

            _getLUTValue(ri, gi, bi) {
                ri = Math.max(0, Math.min(this.size - 1, ri));
                gi = Math.max(0, Math.min(this.size - 1, gi));
                bi = Math.max(0, Math.min(this.size - 1, bi));
                const idx = (ri + gi * this.size + bi * this.size * this.size) * 3;
                return [this.lut[idx], this.lut[idx + 1], this.lut[idx + 2]];
            }

            _trilinearInterpolate(r, g, b) {
                r = Math.max(this.domainMin[0], Math.min(this.domainMax[0], r));
                g = Math.max(this.domainMin[1], Math.min(this.domainMax[1], g));
                b = Math.max(this.domainMin[2], Math.min(this.domainMax[2], b));

                const nr = (r - this.domainMin[0]) / (this.domainMax[0] - this.domainMin[0]);
                const ng = (g - this.domainMin[1]) / (this.domainMax[1] - this.domainMin[1]);
                const nb = (b - this.domainMin[2]) / (this.domainMax[2] - this.domainMin[2]);

                const maxIdx = this.size - 1;
                const rScaled = nr * maxIdx, gScaled = ng * maxIdx, bScaled = nb * maxIdx;
                const r0 = Math.floor(rScaled), g0 = Math.floor(gScaled), b0 = Math.floor(bScaled);
                const r1 = Math.min(r0 + 1, maxIdx), g1 = Math.min(g0 + 1, maxIdx), b1 = Math.min(b0 + 1, maxIdx);
                const rFrac = rScaled - r0, gFrac = gScaled - g0, bFrac = bScaled - b0;

                const c000 = this._getLUTValue(r0, g0, b0), c100 = this._getLUTValue(r1, g0, b0);
                const c010 = this._getLUTValue(r0, g1, b0), c110 = this._getLUTValue(r1, g1, b0);
                const c001 = this._getLUTValue(r0, g0, b1), c101 = this._getLUTValue(r1, g0, b1);
                const c011 = this._getLUTValue(r0, g1, b1), c111 = this._getLUTValue(r1, g1, b1);

                const result = new Array(3);
                for (let ch = 0; ch < 3; ch++) {
                    const c00 = c000[ch] + (c100[ch] - c000[ch]) * rFrac;
                    const c01 = c001[ch] + (c101[ch] - c001[ch]) * rFrac;
                    const c10 = c010[ch] + (c110[ch] - c010[ch]) * rFrac;
                    const c11 = c011[ch] + (c111[ch] - c011[ch]) * rFrac;
                    const c0 = c00 + (c10 - c00) * gFrac;
                    const c1 = c01 + (c11 - c01) * gFrac;
                    result[ch] = c0 + (c1 - c0) * bFrac;
                }
                return result;
            }

            applyToImageData(imageData) {
                if (!this.isLoaded) throw new Error('LUT not loaded');
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    const [rOut, gOut, bOut] = this._trilinearInterpolate(data[i]/255, data[i+1]/255, data[i+2]/255);
                    data[i] = Math.max(0, Math.min(255, Math.round(rOut * 255)));
                    data[i+1] = Math.max(0, Math.min(255, Math.round(gOut * 255)));
                    data[i+2] = Math.max(0, Math.min(255, Math.round(bOut * 255)));
                }
                return imageData;
            }

            applyToImage(img) {
                const canvas = document.createElement('canvas');
                canvas.width = img.naturalWidth || img.width;
                canvas.height = img.naturalHeight || img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                this.applyToImageData(imageData);
                ctx.putImageData(imageData, 0, 0);
                return canvas;
            }
        }

        class LUTManager {
            constructor() {
                this.engines = {};
                this.cache = {};
            }

            loadLUT(slotId, cubeContent, name) {
                const engine = new LUTEngine();
                engine.parse(cubeContent, name);
                this.engines[slotId] = engine;
                console.log(`[LUTManager] Loaded ${slotId}: ${name} (size ${engine.size}³)`);
                return engine;
            }

            isLoaded(slotId) { return this.engines[slotId]?.isLoaded || false; }

            applyLUT(frameId, slotId, img) {
                const cacheKey = `${frameId}_${slotId}`;
                if (this.cache[cacheKey]) {
                    console.log(`[LUTManager] Cache hit: ${cacheKey}`);
                    return this.cache[cacheKey];
                }

                const engine = this.engines[slotId];
                if (!engine?.isLoaded) return null;

                console.log(`[LUTManager] Applying ${slotId} to frame ${frameId}...`);
                const startTime = performance.now();
                const canvas = engine.applyToImage(img);
                const dataURL = canvas.toDataURL('image/png');
                const elapsed = (performance.now() - startTime).toFixed(0);
                console.log(`[LUTManager] Applied in ${elapsed}ms`);

                this.cache[cacheKey] = dataURL;
                return dataURL;
            }

            clearCache() { this.cache = {}; }
        }

        // Global LUT Manager instance
        let lutManager = null;

        /**
         * Initialize LUT system - load all enabled LUTs from LUT_FILES
         */
        function initializeLUTSystem() {
            lutManager = new LUTManager();

            if (typeof LUT_FILES === 'undefined' || !LUT_FILES) {
                console.log('[LUT] No LUT_FILES defined, skipping LUT initialization');
                return;
            }

            // Load global LUT files
            for (let i = 1; i <= 4; i++) {
                const slotId = `lut_${i}`;
                const enabled = LUT_CONFIG && LUT_CONFIG[`lut_${i}_enabled`];
                const name = LUT_CONFIG && LUT_CONFIG[`lut_${i}_default`];
                const content = LUT_FILES[slotId];

                if (enabled && content) {
                    try {
                        let cubeContent = content;
                        // Decode base64 if needed
                        if (content.startsWith('data:')) {
                            cubeContent = atob(content.split(',')[1]);
                        }
                        lutManager.loadLUT(slotId, cubeContent, name);
                    } catch (err) {
                        console.error(`[LUT] Failed to load ${slotId}:`, err);
                    }
                }
            }

            // Load per-frame LUT files (keys like "frame_86694_lut_3")
            // Also load globally-disabled slots that are enabled on specific frames
            if (FRAME_CUSTOM_LOOKS) {
                for (const [frameId, customConfig] of Object.entries(FRAME_CUSTOM_LOOKS)) {
                    for (let i = 1; i <= 4; i++) {
                        if (!customConfig[`lut_${i}_enabled`]) continue;
                        const slotId = `lut_${i}`;
                        const frameLutKey = `frame_${frameId}_${slotId}`;
                        const customName = customConfig[`lut_${i}_default`] || '';

                        // Check for frame-specific LUT file
                        if (LUT_FILES[frameLutKey]) {
                            try {
                                let cubeContent = LUT_FILES[frameLutKey];
                                if (cubeContent.startsWith('data:')) {
                                    cubeContent = atob(cubeContent.split(',')[1]);
                                }
                                lutManager.loadLUT(frameLutKey, cubeContent, customName);
                                console.log(`[LUT] Loaded per-frame LUT: ${customName} -> ${frameLutKey}`);
                            } catch (err) {
                                console.error(`[LUT] Failed to load per-frame ${frameLutKey}:`, err);
                            }
                        }
                        // Also load global slot if not yet loaded (frame enables a globally-disabled slot)
                        else if (!lutManager.isLoaded(slotId) && LUT_FILES[slotId]) {
                            try {
                                let cubeContent = LUT_FILES[slotId];
                                if (cubeContent.startsWith('data:')) {
                                    cubeContent = atob(cubeContent.split(',')[1]);
                                }
                                lutManager.loadLUT(slotId, cubeContent, customName);
                                console.log(`[LUT] Loaded globally-disabled LUT for frame ${frameId}: ${customName} -> ${slotId}`);
                            } catch (err) {
                                console.error(`[LUT] Failed to load ${slotId}:`, err);
                            }
                        }
                    }
                }
            }

            console.log('[LUT] LUT system initialized');
        }

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            console.log(`[${timestamp}] ${message}`);
        }

        // Initial log
        log('Contact sheet initialized');
    </script>

    <!-- GitHub Pages Building Check (New Repos Only) -->
    

    <!-- Version Checking System - Prevents showing stale content -->
    <script>
    (function() {
        const PUBLISH_ID = '20260224_115645_113313';
        let updateBannerShown = false;

        // Helper to get hash parameters
        function getHashParam(name) {
            const hash = window.location.hash;
            console.log('[VersionCheck] Current hash:', hash);
            if (!hash || hash.length <= 1) return null;

            // Remove leading # and parse as URLSearchParams
            const hashContent = hash.substring(1);
            const params = new URLSearchParams(hashContent);
            const value = params.get(name);
            console.log('[VersionCheck] Hash param', name, '=', value);
            return value;
        }

        // Helper to clear hash and cache-busting params without reloading
        function clearHash() {
            console.log('[VersionCheck] Clearing hash and cache-busting params');
            history.replaceState(null, document.title, window.location.pathname);
        }

        // Check if opened from FDS with hash parameter
        const expectedPublishId = getHashParam('fds_check');

        if (expectedPublishId) {
            // Opened from FDS publish flow → show banner immediately
            console.log('[VersionCheck] Opened from FDS with expected publish_id:', expectedPublishId);
            console.log('[VersionCheck] Current page publish_id:', PUBLISH_ID);
            showUpdateBanner();

            if (PUBLISH_ID === expectedPublishId) {
                // We are already on the new version
                console.log('[VersionCheck] Already on new version, hiding banner');
                setTimeout(() => {
                    const banner = document.getElementById('version-update-banner');
                    if (banner) banner.remove();
                    clearHash();
                }, 1000);
            } else {
                // We are on old cached page, keep banner visible until version.json flips
                console.log('[VersionCheck] On old cached page, keeping banner visible');
            }
        } else {
            console.log('[VersionCheck] No hash parameter found, normal operation');
        }

        // Check if this page is outdated
        async function checkVersion() {
            try {
                const response = await fetch('version.json', {
                    cache: 'no-store',
                    headers: { 'Cache-Control': 'no-cache' }
                });

                if (!response.ok) return;

                const data = await response.json();

                // If version.json has a different publish_id, this page is outdated
                if (data.latest !== PUBLISH_ID) {
                    console.log('[VersionCheck] Update detected, refreshing...');
                    showUpdateBanner();
                    // Wait 3 seconds then reload with cache-busting timestamp AND preserve hash
                    setTimeout(() => {
                        const timestamp = Date.now();
                        const hash = window.location.hash || '';
                        window.location.href = window.location.origin + window.location.pathname + '?_=' + timestamp + hash;
                    }, 3000);
                } else {
                    console.log('[VersionCheck] Page is up to date');
                    // Clean URL - remove cache-busting params (but only if no active hash check)
                    if (!expectedPublishId && window.location.search.includes('_=')) {
                        setTimeout(() => {
                            console.log('[VersionCheck] Cleaning cache-busting param from URL');
                            history.replaceState(null, document.title, window.location.pathname);
                        }, 500);
                    }
                    // If we had a hash check and now match, clear the hash
                    if (expectedPublishId && PUBLISH_ID === expectedPublishId) {
                        clearHash();
                    }
                }
            } catch (e) {
                console.log('[VersionCheck] Version check skipped:', e.message);
            }
        }

        function showUpdateBanner() {
            if (updateBannerShown) return;
            updateBannerShown = true;

            const banner = document.createElement('div');
            banner.id = 'version-update-banner';
            banner.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                width: 100% !important;
                background: linear-gradient(135deg, #FF6E31 0%, #FF8C42 100%) !important;
                color: white !important;
                padding: 20px !important;
                text-align: center !important;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif !important;
                font-size: 18px !important;
                font-weight: 700 !important;
                z-index: 2147483647 !important;
                box-shadow: 0 4px 20px rgba(0,0,0,0.5) !important;
                animation: slideDown 0.3s ease-out !important;
                pointer-events: auto !important;
                display: block !important;
                visibility: visible !important;
                opacity: 1 !important;
            `;
            banner.innerHTML = 'Updating... (Banner will disappear when complete)';

            // Add slide-down animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideDown {
                    from {
                        transform: translateY(-100%);
                        opacity: 0;
                    }
                    to {
                        transform: translateY(0);
                        opacity: 1;
                    }
                }
            `;
            document.head.appendChild(style);

            document.body.prepend(banner);
            console.log('[VersionCheck] Update banner shown');
        }

        // Check version on page load
        console.log('[VersionCheck] Initializing with publish_id:', PUBLISH_ID);
        checkVersion();

        // Check every 10 seconds if page is outdated
        setInterval(checkVersion, 10000);

        console.log('[VersionCheck] Auto-refresh enabled (checks every 10 seconds)');
    })();
    </script>
</body>
</html>